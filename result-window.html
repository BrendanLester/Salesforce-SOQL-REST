<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>REST API Result</title>
<style>
body { margin:0; padding:0; font-family:sans-serif; background:#f5f5f5; overflow:hidden; height:100vh; display:flex; flex-direction:column; box-shadow:0 0 0 1px #888; }
.title-bar { display:flex; align-items:center; justify-content:space-between; height:32px; background:#e8e8e8; color:#333; border-bottom:1px solid #ccc; -webkit-app-region:drag; user-select:none; flex-shrink:0; }
.title-bar-drag-region { flex:1; padding-left:12px; font-size:13px; font-weight:500; }
.title-bar-buttons { display:flex; -webkit-app-region:no-drag; }
.title-btn { background:transparent; border:none; color:#333; width:46px; height:32px; font-size:16px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:background 0.15s; }
.title-btn:hover { background:#d0d0d0; }
.title-btn.close-btn { font-size:22px; font-weight:300; line-height:1; }
.title-btn.close-btn:hover { background:#e81123; color:#fff; }
.title-btn.close-all-btn { width:auto; padding:0 12px; font-size:12px; border-right:1px solid #ccc; }
.title-btn.close-all-btn:hover { background:#dc3545; color:#fff; }
.title-btn.minimize-btn { font-size:18px; }
.container { width:100%; margin:0; background:#fff; padding:0; border-radius:0; box-shadow:none; flex:1; overflow:hidden; box-sizing:border-box; display:flex; flex-direction:column; }
.header { display:flex; justify-content:space-between; align-items:center; margin-bottom:0; border-bottom:2px solid #0066cc; padding:20px 20px 10px 20px; flex-shrink:0; }
h1 { margin:0; color:#333; font-size:16px; font-family:sans-serif; }
.action-btn { padding:4px 8px; font-size:12px; cursor:pointer; }
.action-btn.sf-link { background:#0066cc; color:#fff; }
#content { flex:1; overflow:auto; padding:20px; position:relative; }
.loading { display:flex; align-items:center; justify-content:center; height:100%; color:#666; font-size:14px; }
pre { background:#f8f8f8; padding:15px; border-radius:4px; overflow:auto; font-family:monospace; font-size:14px; line-height:1.5; border:1px solid #ddd; cursor:text; user-select:text; max-height:none; }
pre:focus { outline:none; }
.error { background:#f8d7da; color:#721c24; padding:15px; border-radius:4px; border:1px solid #f5c6cb; }
.search-box { position:absolute; top:10px; right:10px; background:#fff; border:2px solid #0066cc; border-radius:4px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:1000; display:none; }
.search-box input { border:1px solid #ccc; padding:4px; margin-right:4px; font-size:12px; }
.search-box button { background:#0066cc; color:white; border:none; padding:4px 8px; cursor:pointer; font-size:12px; }
.search-box button:hover { background:#0052a3; }
.search-highlight { background:#ffff00; color:#000; }
.search-current { background:#ff6600; color:#fff; }
</style>
</head>
<body>
<div class="title-bar">
    <div class="title-bar-drag-region">REST API Result</div>
    <div class="title-bar-buttons">
        <button id="closeAllBtn" class="title-btn close-all-btn" title="Close All Popups">‚úï Close All</button>
        <button class="title-btn close-btn" onclick="window.close()" title="Close">√ó</button>
    </div>
</div>
<div class="container">
    <div class="header">
        <div>
            <h1>REST API Result</h1>
            <div id="lineCountInfo" style="font-size:12px; color:#666; margin-top:4px;"></div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
            <label style="display:flex; align-items:center; gap:4px; font-size:12px; cursor:pointer;" title="Convert UTC datetime to local timezone">
                <input type="checkbox" id="convertUtcCheckbox" onchange="toggleUtcConversion()" style="cursor:pointer;">
                <span>Local Time</span>
            </label>
            <button id="copyBtn" class="action-btn" style="display:none;">üìã Copy</button>
            <button id="exportBtn" class="action-btn" style="display:none;">üìÑ Export JSON</button>
            <button id="openInSF" class="action-btn sf-link" style="display:none;">Open in Salesforce</button>
        </div>
    </div>
    <div id="content"><div class="loading">‚è≥ Loading...</div></div>
    <div id="searchBox" class="search-box">
        <input type="text" placeholder="Search..." id="searchInput">
        <span id="matchCount" style="font-size:11px; color:#666; margin-right:4px;"></span>
        <button onclick="findNext()" title="Find Next (Enter)">‚Üì</button>
        <button onclick="findPrev()" title="Find Previous (Shift+Enter)">‚Üë</button>
        <button onclick="closeSearch()" title="Close (Escape)">‚úï</button>
    </div>
</div>

<script>
const { ipcRenderer } = require('electron');

// UTC to Local conversion state
let convertUtcToLocal = false;
let originalResultData = null;

// Detect if a string is an ISO 8601 UTC datetime
function isUtcDateTime(value) {
    if (typeof value !== 'string') return false;
    // Match ISO 8601 formats (Salesforce uses these):
    const isoDateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{4}|[+-]00:00)$/;
    return isoDateRegex.test(value);
}

// Convert UTC datetime string to local datetime string
function convertToLocalDateTime(utcString) {
    try {
        const date = new Date(utcString);
        if (isNaN(date.getTime())) return utcString;
        
        // Format: 2026-01-06T19:37:22.000+0000 (same format, local time and timezone)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
        
        // Get timezone offset in format +0000 or -0500
        const offset = -date.getTimezoneOffset();
        const offsetHours = String(Math.floor(Math.abs(offset) / 60)).padStart(2, '0');
        const offsetMinutes = String(Math.abs(offset) % 60).padStart(2, '0');
        const offsetSign = offset >= 0 ? '+' : '-';
        const timezoneStr = `${offsetSign}${offsetHours}${offsetMinutes}`;
        
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}${timezoneStr}`;
    } catch {
        return utcString;
    }
}

// Recursively convert datetime values in an object or array
function convertDatetimesInObject(obj) {
    if (obj === null || obj === undefined) return obj;
    
    if (Array.isArray(obj)) {
        return obj.map(item => convertDatetimesInObject(item));
    }
    
    if (typeof obj === 'object') {
        const newObj = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = convertDatetimesInObject(obj[key]);
            }
        }
        return newObj;
    }
    
    // If it's a string that looks like a datetime, convert it
    if (typeof obj === 'string' && isUtcDateTime(obj)) {
        return convertToLocalDateTime(obj);
    }
    
    return obj;
}

// Toggle UTC to local datetime conversion
function toggleUtcConversion() {
    const checkbox = document.getElementById('convertUtcCheckbox');
    convertUtcToLocal = checkbox.checked;
    
    if (originalResultData) {
        renderResult(originalResultData, true); // Pass true to indicate toggle (preserve scroll)
    }
}

// Render result with conversion applied
function renderResult(resultData, isToggle = false) {
    const contentDiv = document.getElementById('content');
    const copyBtn = document.getElementById('copyBtn');
    const exportBtn = document.getElementById('exportBtn');
    
    // Save current scroll position if toggling
    const savedScrollTop = isToggle ? contentDiv.scrollTop : 0;
    
    const pre = document.createElement('pre');
    const displayData = convertUtcToLocal ? convertDatetimesInObject(resultData) : resultData;
    const jsonText = JSON.stringify(displayData, null, 2);
    pre.textContent = jsonText;
    pre.tabIndex = 0;
    contentDiv.innerHTML = '';
    contentDiv.appendChild(pre);
    
    // Update line count info
    const lineCount = jsonText.split('\n').length;
    const lineCountInfo = document.getElementById('lineCountInfo');
    if (lineCountInfo) {
        lineCountInfo.textContent = `${lineCount} lines`;
    }
    
    // Handle Ctrl+A to select only JSON text
    pre.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a') {
            e.preventDefault();
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(pre);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    });
    
    setTimeout(() => {
        pre.focus();
        if (isToggle) {
            // Restore scroll position when toggling
            contentDiv.scrollTop = savedScrollTop;
        } else {
            // Scroll to top on initial render
            pre.scrollTop = 0;
            contentDiv.scrollTop = 0;
        }
    }, 100);
    
    // Update copy button to use current display data
    copyBtn.onclick = async () => {
        try {
            await navigator.clipboard.writeText(jsonText);
            const originalText = copyBtn.textContent;
            copyBtn.textContent = '‚úì Copied!';
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 2000);
        } catch (err) {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        }
    };
    
    // Update export button to use current display data
    exportBtn.onclick = () => {
        const blob = new Blob([jsonText], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const now = new Date();
        const timestamp = now.getFullYear() + '-' + 
            String(now.getMonth() + 1).padStart(2, '0') + '-' + 
            String(now.getDate()).padStart(2, '0') + 'T' + 
            String(now.getHours()).padStart(2, '0') + '-' + 
            String(now.getMinutes()).padStart(2, '0') + '-' + 
            String(now.getSeconds()).padStart(2, '0');
        const recordId = resultData.Id || 'record';
        a.download = `${recordId}_${timestamp}.json`;
        a.click();
        URL.revokeObjectURL(url);
    };
}

// Search functionality
let currentMatches = [];
let currentMatchIndex = -1;
let currentSearchText = '';

function openSearch() {
    const searchBox = document.getElementById('searchBox');
    const input = document.getElementById('searchInput');
    searchBox.style.display = 'block';
    input.value = '';
    input.focus();
}

function closeSearch() {
    const searchBox = document.getElementById('searchBox');
    searchBox.style.display = 'none';
    clearHighlights();
}

function clearHighlights() {
    const content = document.getElementById('content');
    const highlights = content.querySelectorAll('.search-highlight, .search-current');
    highlights.forEach(span => {
        const parent = span.parentNode;
        parent.replaceChild(document.createTextNode(span.textContent), span);
        parent.normalize();
    });
    document.getElementById('matchCount').textContent = '';
    currentMatches = [];
    currentMatchIndex = -1;
}

function findInContent(searchText, direction = 1) {
    if(!searchText) return;
    
    const content = document.getElementById('content');
    
    // Only rebuild matches if search text changed
    if(currentSearchText !== searchText) {
        clearHighlights();
        currentSearchText = searchText;
        currentMatches = [];
        currentMatchIndex = 0;
        
        highlightMatches(searchText, 0);
    } else {
        // Navigate through existing matches
        currentMatchIndex += direction;
        if(currentMatchIndex >= currentMatches.length) currentMatchIndex = 0;
        if(currentMatchIndex < 0) currentMatchIndex = currentMatches.length - 1;
        
        // Update highlight classes
        const highlights = content.querySelectorAll('.search-highlight, .search-current');
        highlights.forEach((span, index) => {
            span.className = index === currentMatchIndex ? 'search-current' : 'search-highlight';
            if(index === currentMatchIndex) {
                span.id = 'current-search-match';
            } else {
                span.removeAttribute('id');
            }
        });
    }
    
    // Update match counter
    const counter = document.getElementById('matchCount');
    if(currentMatches.length > 0) {
        counter.textContent = `${currentMatchIndex + 1} of ${currentMatches.length}`;
    }
    
    // Scroll to current match
    setTimeout(() => {
        const currentMatch = document.getElementById('current-search-match');
        if(currentMatch) {
            currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        }
    }, 10);
}

function highlightMatches(searchText, currentIndex) {
    const content = document.getElementById('content');
    const regex = new RegExp(escapeRegex(searchText), 'gi');
    let matchIndex = 0;
    
    function highlightTextNode(node) {
        if(node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            const matches = [];
            let match;
            regex.lastIndex = 0;
            while((match = regex.exec(text)) !== null) {
                matches.push({ start: match.index, end: match.index + match[0].length, text: match[0] });
            }
            
            if(matches.length > 0) {
                const fragment = document.createDocumentFragment();
                let lastEnd = 0;
                
                matches.forEach(m => {
                    if(m.start > lastEnd) {
                        fragment.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
                    }
                    
                    const span = document.createElement('span');
                    span.className = matchIndex === currentIndex ? 'search-current' : 'search-highlight';
                    if(matchIndex === currentIndex) {
                        span.id = 'current-search-match';
                    }
                    span.textContent = m.text;
                    fragment.appendChild(span);
                    
                    currentMatches.push(matchIndex);
                    lastEnd = m.end;
                    matchIndex++;
                });
                
                if(lastEnd < text.length) {
                    fragment.appendChild(document.createTextNode(text.substring(lastEnd)));
                }
                
                node.parentNode.replaceChild(fragment, node);
            }
        } else if(node.nodeType === Node.ELEMENT_NODE) {
            if(!node.classList.contains('search-highlight') && !node.classList.contains('search-current')) {
                Array.from(node.childNodes).forEach(child => highlightTextNode(child));
            }
        }
    }
    
    highlightTextNode(content);
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findNext() {
    const input = document.getElementById('searchInput');
    const searchText = input.value.trim();
    if(searchText) findInContent(searchText, 1);
}

function findPrev() {
    const input = document.getElementById('searchInput');
    const searchText = input.value.trim();
    if(searchText) findInContent(searchText, -1);
}

// Search input handlers
document.getElementById('searchInput').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
        e.preventDefault();
        if(e.shiftKey) {
            findPrev();
        } else {
            findNext();
        }
    } else if(e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        closeSearch();
    }
});

document.getElementById('searchInput').addEventListener('input', e => {
    const searchText = e.target.value.trim();
    if(searchText && searchText.length >= 2) {
        currentSearchText = '';
        findInContent(searchText, 1);
    } else {
        clearHighlights();
    }
});

// Ctrl+F handler
document.addEventListener('keydown', e => {
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearch();
    }
});

// Close all popups button handler (in title bar)
const closeAllBtn = document.getElementById('closeAllBtn');
if (closeAllBtn) {
    closeAllBtn.addEventListener('click', async (e) => {
        e.stopPropagation(); // Prevent drag region interference
        try {
            await ipcRenderer.invoke('close-all-popups');
        } catch (err) {
            console.error('Error closing all popups:', err);
        }
    });
}

// Close window on Escape key (only if search box is not open)
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        const searchBox = document.getElementById('searchBox');
        if (searchBox && searchBox.style.display === 'block') {
            // If search is open, close it first
            closeSearch();
        } else {
            // If search is closed, close the window
            window.close();
        }
    }
});

// Request the result data from main process
ipcRenderer.invoke('get-result-data').then(resultWrapper => {
    const contentDiv = document.getElementById('content');
    const openInSFBtn = document.getElementById('openInSF');
    const copyBtn = document.getElementById('copyBtn');
    const exportBtn = document.getElementById('exportBtn');
    const checkbox = document.getElementById('convertUtcCheckbox');
    
    if (!resultWrapper) {
        contentDiv.innerHTML = '<div class="error">No data available</div>';
        return;
    }
    
    // Extract data and conversion state
    const resultData = resultWrapper.data || resultWrapper;
    const inheritedConversion = resultWrapper.convertUtcToLocal || false;
    
    // Set checkbox state to match main window
    convertUtcToLocal = inheritedConversion;
    checkbox.checked = convertUtcToLocal;
    
    if (!resultData) {
        contentDiv.innerHTML = '<div class="error">No data available</div>';
        return;
    }
    
    if (resultData.error) {
        contentDiv.innerHTML = `<div class="error">${resultData.error}</div>`;
    } else {
        // Store original data
        originalResultData = resultData;
        
        // Render with current conversion setting
        renderResult(resultData);
        
        // Show buttons
        copyBtn.style.display = 'block';
        exportBtn.style.display = 'block';
        
        // Update title with object type if available
        if (resultData.attributes && resultData.attributes.type) {
            const recordId = resultData.Id || 'Record';
            const titleText = `${resultData.attributes.type} - ${recordId}`;
            document.title = titleText;
            // Get line count from rendered JSON
            const pre = document.querySelector('#content pre');
            const lineCount = pre ? pre.textContent.split('\n').length : 0;
            document.querySelector('h1').textContent = `${resultData.attributes.type} - ${recordId}`;
            const lineCountInfo = document.getElementById('lineCountInfo');
            if (lineCountInfo) {
                lineCountInfo.textContent = `${lineCount} lines`;
            }
            const titleBarDragRegion = document.querySelector('.title-bar-drag-region');
            if (titleBarDragRegion) {
                titleBarDragRegion.textContent = titleText;
            }
        }
        
        // Show "Open in Salesforce" button if we have an ID
        if (resultData.Id) {
            openInSFBtn.style.display = 'block';
            openInSFBtn.addEventListener('click', async () => {
                try {
                    const config = await ipcRenderer.invoke('get-current-config');
                    if (config && config.instanceUrl) {
                        const url = `${config.instanceUrl}/${resultData.Id}`;
                        await ipcRenderer.invoke('open-external', url);
                    } else {
                        alert('Cannot determine Salesforce URL');
                    }
                } catch (err) {
                    console.error('Error opening Salesforce URL:', err);
                    alert('Failed to open Salesforce URL');
                }
            });
        }
    }
}).catch(err => {
    document.getElementById('content').innerHTML = `<div class="error">Error loading data: ${err.message}</div>`;
});
</script>
</body>
</html>
