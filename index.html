<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Playforce Query</title>
<script>
try {
    // Setup API bridge directly in renderer
    const { ipcRenderer } = require('electron');

    window.api = {
        executeSOQL: (query, queryId) => ipcRenderer.invoke('execute-soql', query, queryId),
        executeREST: (path) => ipcRenderer.invoke('execute-rest', path),
        abortQuery: (queryId) => ipcRenderer.invoke('abort-query', queryId),
        setConfigFile: (configName) => ipcRenderer.invoke('set-config-file', configName),
        listConfigs: () => ipcRenderer.invoke('list-configs'),
        getCurrentConfig: () => ipcRenderer.invoke('get-current-config'),
        requiresOAuth: () => ipcRenderer.invoke('requires-oauth'),
        tryAuthenticate: () => ipcRenderer.invoke('try-authenticate'),
        hasValidToken: () => ipcRenderer.invoke('has-valid-token'),
        startOAuthFlow: () => ipcRenderer.invoke('start-oauth-flow'),
        exchangeAuthCode: (authCode, redirectUri) => ipcRenderer.invoke('exchange-auth-code', authCode, redirectUri),
        onOAuthCallback: (callback) => ipcRenderer.on('oauth-callback', (event, code) => callback(code)),
        onOAuthError: (callback) => ipcRenderer.on('oauth-error', (event, error) => callback(error)),
        onSOQLProgress: (callback) => ipcRenderer.on('soql-progress', (event, progress) => callback(progress)),
        describeGlobal: () => ipcRenderer.invoke('describe-global'),
        describeObject: (objectName) => ipcRenderer.invoke('describe-object', objectName),
        openExternal: (url) => ipcRenderer.invoke('open-external', url),
        openResultWindow: (data) => ipcRenderer.invoke('open-result-window', data),
        closeAllPopups: () => ipcRenderer.invoke('close-all-popups')
    };

    // Load CodeMirror editor setup
    require('./renderer.js');
} catch (error) {
    console.error('Error in head script:', error);
}
</script>
<style>
body { margin:0; height:100vh; display:flex; flex-direction:column; font-family:sans-serif; }
#toolbar { display:flex; gap:10px; padding:8px; background:#e8e8e8; border-bottom:1px solid #ccc; }
#toolbar button { padding:6px 12px; background:#0066cc; color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px; }
#toolbar button:hover { background:#0052a3; }
#toolbar input[type="file"] { display:none; }
#top, #bottom { flex:1; overflow:hidden; }
#splitter { height:5px; background:#888; cursor:row-resize; position:relative; z-index:100; flex-shrink:0; }
#editor { width:100%; height:100%; }
#log { padding:2px 2px 8px 2px; font-family:monospace; font-size:14px; overflow:hidden; flex:1; outline:none; position:relative; }
#log:focus { box-shadow: inset 0 0 0 2px #0066cc; }
#logContent { height:100%; overflow:auto; padding:2px 6px 12px 6px; box-sizing:border-box; }
.log-line { padding:2px 0; border-bottom:1px solid #ccc; }
table { width:100%; border-collapse:separate; border-spacing:0; font-family:monospace; font-size:14px; margin-bottom:20px; }
th, td { border:1px solid #ccc; padding:4px 8px; text-align:left; }
th { background:#eee; position:sticky; top:0; z-index:10; }
th::before { content:''; position:absolute; left:0; right:0; top:-8px; height:8px; background:#fff; z-index:1; }
th::after { content:attr(data-content); position:relative; z-index:2; }
th.sortable { cursor:pointer; user-select:none; }
th.sortable:hover { background:#ddd; }
th.sorted::after { margin-left:5px; }
th.sorted.asc::after { content:'‚ñ≤'; }
th.sorted.desc::after { content:'‚ñº'; }
th.filter-row { background:#f9f9f9; position:sticky; top:0; z-index:9; cursor:default; }
th.filter-row:hover { background:#f9f9f9; }
.filter-input { width:90%; padding:2px 4px; font-size:11px; border:1px solid #ccc; border-radius:2px; font-family:monospace; }
.filter-input:focus { outline:none; border-color:#0066cc; }
.filter-row-hidden { display:none; }
.filter-toggle-icon { cursor:pointer; font-size:inherit; user-select:none; opacity:0.6; display:inline-block; margin-left:4px; }
.filter-toggle-icon:hover { opacity:1; }
.filter-toggle-icon.active { opacity:1; }
.clear-filters-icon { cursor:pointer; font-size:inherit; user-select:none; color:#666; display:none; margin-left:4px; }
.clear-filters-icon:hover { opacity:0.7; }
th.sorted::after { margin-left:5px; }
th.sorted.asc::after { content:'‚ñ≤'; }
th.sorted.desc::after { content:'‚ñº'; }
tr:nth-child(even) { background:#f9f9f9; }
tr:hover { background:#fffae6; }
.keyword { color:#d73a49; font-weight:bold; }

#results-header { display:flex; justify-content:flex-end; align-items:center; gap:8px; padding:4px 8px; border-bottom:1px solid #ccc; background:#f5f5f5; }
#copyResultsBtn { padding:4px 8px; font-size:12px; cursor:pointer; }
#stopQueryBtn { padding:4px 8px; font-size:12px; cursor:pointer; background:#dc3545; color:white; border:none; border-radius:4px; display:none; }
#stopQueryBtn:hover { background:#c82333; }
#exportJsonBtn, #exportCsvBtn { padding:4px 8px; font-size:12px; cursor:pointer; }
#clearFiltersBtn { padding:4px 8px; font-size:12px; cursor:pointer; background:#6c757d; color:white; border:none; border-radius:4px; display:none; }
#clearFiltersBtn:hover { background:#5a6268; }

.search-box { position:absolute; top:10px; right:10px; background:#fff; border:2px solid #0066cc; border-radius:4px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:1000; display:none; }
.search-box input { border:1px solid #ccc; padding:4px; margin-right:4px; font-size:12px; }
.search-box button { background:#0066cc; color:white; border:none; padding:4px 8px; cursor:pointer; font-size:12px; }
.search-box button:hover { background:#0052a3; }
.search-highlight { background:#ffff00; color:#000; }
.search-current { background:#ff6600; color:#fff; }

#autocomplete { position:fixed; background:#fff; border:1px solid #0066cc; border-radius:4px; box-shadow:0 4px 8px rgba(0,0,0,0.2); max-height:200px; overflow-y:auto; z-index:9999; display:none; min-width:150px; }
.autocomplete-item { padding:6px 12px; cursor:pointer; font-family:monospace; font-size:13px; }
.autocomplete-item:hover { background:#e6f2ff; }
.autocomplete-item.selected { background:#0066cc; color:white; }
.autocomplete-hint { font-size:11px; color:#888; margin-left:8px; }
.autocomplete-relationship { color:#0066cc; font-weight:bold; }


#helpModal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:10000; display:none; align-items:center; justify-content:center; }
#helpContent { background:#fff; border-radius:8px; padding:20px; max-width:400px; box-shadow:0 4px 16px rgba(0,0,0,0.3); }
#helpContent h3 { margin:0 0 15px 0; color:#333; border-bottom:2px solid #0066cc; padding-bottom:8px; }
#helpContent table { width:100%; border-collapse:collapse; font-family:monospace; font-size:13px; }
#helpContent td { padding:6px 8px; border-bottom:1px solid #eee; }
#helpContent td:first-child { font-weight:bold; color:#0066cc; white-space:nowrap; }
#helpContent td:last-child { color:#666; }
#helpClose { float:right; background:#0066cc; color:white; border:none; padding:4px 12px; border-radius:4px; cursor:pointer; font-size:12px; margin-top:10px; }
#helpClose:hover { background:#0052a3; }
</style>
</head>
<body>
<div id="toolbar">
    <button onclick="saveSession()">üíæ Save Session</button>
    <button onclick="document.getElementById('fileInput').click()">üìÇ Load Session</button>
    <input type="file" id="fileInput" accept=".txt,.soql" onchange="loadSession(event)">
    
    <select id="envSelector" onchange="changeEnvironment()" style="margin-left:20px; padding:6px 12px; border-radius:4px; border:1px solid #ccc;">
        <option value="">Select Environment</option>
    </select>
    
    <div style="margin-left:auto; font-size:12px; color:#666; display:flex; flex-direction:column; align-items:flex-end; gap:2px;">
        <span>Press Ctrl+E on a query block to execute SOQL or REST</span>
        <span onclick="toggleHelp()" style="cursor:pointer; text-decoration:underline; font-size:11px;" title="Keyboard Shortcuts">Help</span>
    </div>
</div>

<div id="helpModal" onclick="if(event.target===this) toggleHelp()">
    <div id="helpContent">
        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
        <table>
            <tr><td>Ctrl+E</td><td>Execute query block</td></tr>
            <tr><td>Ctrl+F</td><td>Find in editor/results</td></tr>
            <tr><td>Ctrl+A</td><td>Select all (in results)</td></tr>
            <tr><td>Tab / Enter</td><td>Select autocomplete item</td></tr>
            <tr><td>, (comma)</td><td>Select item + add comma</td></tr>
            <tr><td>. (period)</td><td>Select relation + traverse</td></tr>
            <tr><td>‚Üë ‚Üì</td><td>Navigate autocomplete</td></tr>
            <tr><td>PgUp / PgDn</td><td>Jump 5 items</td></tr>
            <tr><td>Escape</td><td>Close popup/search</td></tr>
        </table>
        <div style="margin-top:12px; padding:8px; background:#f8f9fa; border-radius:4px; font-size:11px; color:#555;">
            <strong>REST Syntax:</strong> Type <code style="background:#e9ecef; padding:2px 4px; border-radius:2px;">ObjectName/Id</code><br>
            Example: <code style="background:#e9ecef; padding:2px 4px; border-radius:2px;">Account/001xx000003DGb0AAG</code>
        </div>
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid #eee; font-size:12px; color:#666; text-align:center;">
            Learn more at <a href="#" onclick="event.preventDefault(); window.api.openExternal('https://getplayforce.com/')" style="color:#0066cc;">getplayforce.com</a>
        </div>
        <button id="helpClose" onclick="toggleHelp()">Close</button>
    </div>
</div>

<div id="top" style="background:#f0f0f0; position:relative;">
<div id="editor"></div>
</div>
<div id="splitter"></div>
<div id="bottom" style="background:#fff; display:flex; flex-direction:column; position:relative;">
    <div id="results-header">
        <span id="resultsCount" style="font-size:14px; font-family:monospace; color:#666; margin-right:auto;"></span>
        <label style="display:flex; align-items:center; gap:4px; font-size:12px; cursor:pointer; margin-right:8px;" title="Convert UTC datetime to local timezone">
            <input type="checkbox" id="convertUtcCheckbox" onchange="toggleUtcConversion()" style="cursor:pointer;">
            <span>Local Time</span>
        </label>
        <button id="copyResultsBtn" tabindex="-1">üìã Copy</button>
        <button id="stopQueryBtn" onclick="stopQuery()">‚èπ Stop Query</button>
        <button id="exportJsonBtn" onclick="exportToJSON()" tabindex="-1" style="display:none;">üìÑ Export JSON</button>
        <button id="exportCsvBtn" onclick="exportToCSV()" tabindex="-1" style="display:none;">üìä Export CSV</button>
    </div>
    <div id="log" tabindex="0">
        <div id="logContent">üëâ Select an environment first, then press Ctrl+E on a block above to execute.</div>
    </div>
    <div id="logSearch" class="search-box">
        <input type="text" placeholder="Search..." id="logSearchInput">
        <span id="logMatchCount" style="font-size:11px; color:#666; margin-right:4px;"></span>
        <button onclick="findNext('log')" title="Find Next (Enter)">‚Üì</button>
        <button onclick="findPrev('log')" title="Find Previous (Shift+Enter)">‚Üë</button>
        <button onclick="closeSearch('log')" title="Close (Escape)">‚úï</button>
    </div>
</div>

<script>
// Global variable to store the actual OAuth redirect URI
let currentRedirectUri = null;

// Autocomplete state
let sobjectsCache = null; // Cached list of SObjects
let objectFieldsCache = {}; // Cached field metadata per object: { objectName: fieldsArray }


// Store current result data for export
let currentResultData = null;

// Sort state
let currentSortColumn = null;
let currentSortDirection = 'asc';

// Filter state
let columnFilters = {};
let filtersVisible = false;

// UTC to Local conversion state
let convertUtcToLocal = false;
let originalElapsedTime = null;

// Detect if a string is an ISO 8601 UTC datetime
function isUtcDateTime(value) {
    if (typeof value !== 'string') return false;
    // Match ISO 8601 formats (Salesforce uses these):
    // 2024-01-08T12:34:56.000Z
    // 2024-01-08T12:34:56Z
    // 2024-01-08T12:34:56.000+0000
    // 2024-01-08T12:34:56+0000
    const isoDateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{4}|[+-]00:00)$/;
    return isoDateRegex.test(value);
}

// Convert UTC datetime string to local datetime string
function convertToLocalDateTime(utcString) {
    try {
        const date = new Date(utcString);
        if (isNaN(date.getTime())) return utcString;
        
        // Format: 2026-01-06T19:37:22.000+0000 (same format, local time and timezone)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
        
        // Get timezone offset in format +0000 or -0500
        const offset = -date.getTimezoneOffset();
        const offsetHours = String(Math.floor(Math.abs(offset) / 60)).padStart(2, '0');
        const offsetMinutes = String(Math.abs(offset) % 60).padStart(2, '0');
        const offsetSign = offset >= 0 ? '+' : '-';
        const timezoneStr = `${offsetSign}${offsetHours}${offsetMinutes}`;
        
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}${timezoneStr}`;
    } catch {
        return utcString;
    }
}

// Toggle UTC to local datetime conversion
function toggleUtcConversion() {
    const checkbox = document.getElementById('convertUtcCheckbox');
    convertUtcToLocal = checkbox.checked;
    console.log('UTC conversion toggled:', convertUtcToLocal);
    
    // Re-render the table if data exists
    if (currentResultData) {
        console.log('Re-rendering with currentResultData:', currentResultData);
        
        // Show visual feedback
        checkbox.disabled = true;
        document.body.style.cursor = 'wait';
        const resultsCount = document.getElementById('resultsCount');
        const originalText = resultsCount.textContent;
        resultsCount.textContent = convertUtcToLocal ? 'Converting to local time...' : 'Reverting to UTC...';
        
        // Use setTimeout to allow UI to update before heavy rendering
        setTimeout(() => {
            // Clear current table and re-render
            logContent.innerHTML = '';
            currentTable = null;
            currentTbody = null;
            renderResult(currentResultData, true);
            
            // Restore UI
            checkbox.disabled = false;
            document.body.style.cursor = '';
            resultsCount.textContent = originalText;
        }, 50);
    } else {
        console.log('No currentResultData to re-render');
    }
}

// Recursively convert datetime values in an object or array
function convertDatetimesInObject(obj) {
    if (obj === null || obj === undefined) return obj;
    
    if (Array.isArray(obj)) {
        return obj.map(item => convertDatetimesInObject(item));
    }
    
    if (typeof obj === 'object') {
        const newObj = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = convertDatetimesInObject(obj[key]);
            }
        }
        return newObj;
    }
    
    // If it's a string that looks like a datetime, convert it
    if (typeof obj === 'string' && isUtcDateTime(obj)) {
        return convertToLocalDateTime(obj);
    }
    
    return obj;
}

// Toggle help modal
function toggleHelp() {
    const modal = document.getElementById('helpModal');
    if (modal.style.display === 'flex') {
        modal.style.display = 'none';
    } else {
        modal.style.display = 'flex';
    }
}

// Export results to JSON
function exportToJSON() {
    if (!currentResultData) return;
    
    // Get filtered records
    let dataToExport = currentResultData;
    const records = currentResultData.records || currentResultData;
    
    // Apply filters if any are active
    const activeFilters = Object.keys(columnFilters).filter(key => columnFilters[key]);
    if (activeFilters.length > 0 && Array.isArray(records)) {
        const filteredRecords = records.filter(record => {
            return activeFilters.every(fieldName => {
                const filterValue = columnFilters[fieldName];
                let cellValue = record[fieldName];
                
                if (cellValue === null || cellValue === undefined) cellValue = '';
                if (typeof cellValue === 'object') {
                    if (cellValue.Name || cellValue.name) cellValue = cellValue.Name || cellValue.name;
                    else cellValue = JSON.stringify(cellValue);
                }
                cellValue = String(cellValue).toLowerCase();
                
                return cellValue.includes(filterValue);
            });
        });
        
        // Preserve structure for SOQL results
        if (currentResultData.records) {
            dataToExport = { ...currentResultData, records: filteredRecords, totalSize: filteredRecords.length };
        } else {
            dataToExport = filteredRecords;
        }
    }
    
    const jsonStr = JSON.stringify(dataToExport, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const now = new Date();
    const timestamp = now.getFullYear() + '-' + 
        String(now.getMonth() + 1).padStart(2, '0') + '-' + 
        String(now.getDate()).padStart(2, '0') + 'T' + 
        String(now.getHours()).padStart(2, '0') + '-' + 
        String(now.getMinutes()).padStart(2, '0') + '-' + 
        String(now.getSeconds()).padStart(2, '0');
    a.download = `export_${timestamp}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

// Export results to CSV
function exportToCSV() {
    if (!currentResultData) return;
    
    let records = currentResultData.records || currentResultData;
    if (!records || records.length === 0) return;
    
    // Apply filters if any are active
    const activeFilters = Object.keys(columnFilters).filter(key => columnFilters[key]);
    if (activeFilters.length > 0) {
        records = records.filter(record => {
            return activeFilters.every(fieldName => {
                const filterValue = columnFilters[fieldName];
                let cellValue = record[fieldName];
                
                if (cellValue === null || cellValue === undefined) cellValue = '';
                if (typeof cellValue === 'object') {
                    if (cellValue.Name || cellValue.name) cellValue = cellValue.Name || cellValue.name;
                    else cellValue = JSON.stringify(cellValue);
                }
                cellValue = String(cellValue).toLowerCase();
                
                return cellValue.includes(filterValue);
            });
        });
    }
    
    if (records.length === 0) {
        alert('No records to export after filtering');
        return;
    }
    
    // Get headers (excluding attributes)
    const headers = Object.keys(records[0]).filter(h => h !== 'attributes');
    
    // Build CSV
    let csv = headers.join(',') + '\n';
    
    records.forEach(record => {
        const row = headers.map(header => {
            let value = record[header];
            
            // Handle null/undefined
            if (value === null || value === undefined) return '';
            
            // Handle nested objects (like relationships)
            if (typeof value === 'object') {
                value = JSON.stringify(value);
            }
            
            // Convert to string and escape
            value = String(value);
            
            // Escape quotes and wrap in quotes if contains comma, quote, or newline
            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                value = '"' + value.replace(/"/g, '""') + '"';
            }
            
            return value;
        });
        csv += row.join(',') + '\n';
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const now = new Date();
    const timestamp = now.getFullYear() + '-' + 
        String(now.getMonth() + 1).padStart(2, '0') + '-' + 
        String(now.getDate()).padStart(2, '0') + 'T' + 
        String(now.getHours()).padStart(2, '0') + '-' + 
        String(now.getMinutes()).padStart(2, '0') + '-' + 
        String(now.getSeconds()).padStart(2, '0');
    a.download = `export_${timestamp}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

// Highlight SOQL keywords
function highlightSOQL(query) {
    const keywords = /\b(SELECT|FROM|WHERE|LIMIT|ORDER BY|GROUP BY|AND|OR|NOT|NULL)\b/gi;
    return query.replace(keywords, '<span class="keyword">$1</span>');
}

// Environment functions
async function loadEnvironments() {
    if (!window.api?.listConfigs) {
        console.error('window.api.listConfigs not available');
        return;
    }
    
    try {
        const configs = await window.api.listConfigs();
        
        const selector = document.getElementById('envSelector');
        while (selector.children.length > 1) selector.removeChild(selector.lastChild);
        if (!configs.length) {
            const opt = document.createElement('option'); opt.textContent='No configs found'; opt.disabled=true; selector.appendChild(opt);
        } else {
            configs.forEach(c=>{ const opt=document.createElement('option'); opt.value=c; opt.textContent=c; selector.appendChild(opt); });
        }
    } catch (error) {
        console.error('Error loading environments:', error);
    }
}

async function changeEnvironment() {
    const sel=document.getElementById('envSelector'); if(!sel.value) return;
    
    // Cancel any running query before switching
    if (currentQueryId) {
        await stopQuery();
    }
    
    try {
        const success = await window.api.setConfigFile(sel.value);
        if(success){
            // Clear autocomplete caches when switching environments
            sobjectsCache = null;
            objectFieldsCache = {};
            
            logContent.innerHTML='';
            const msg = document.createElement('div');
            msg.className='log-line';
            msg.style.background="#d1ecf1"; msg.style.color="#0c5460"; msg.style.padding="5px";
            msg.textContent=`üîÑ Switched to ${sel.value} environment`;
            logContent.appendChild(msg);
            document.title = `Playforce Query - ${sel.value}`;
            
            // Auto-authenticate based on grant type
            await autoAuthenticate();
            
            // Eagerly fetch object list for autocomplete
            fetchSObjects().catch(err => console.log('Could not pre-fetch objects:', err.message));
        } else alert('Failed to switch environment');
    } catch(err){ alert(err.message); }
}

// Auto-authenticate based on grant type
async function autoAuthenticate() {
    const log = document.getElementById('logContent');
    
    try {
        // First check if we already have a valid token for this environment
        const hasToken = await window.api.hasValidToken();
        
        if (hasToken) {
            // Already authenticated - just show ready message
            const readyMsg = document.createElement('div');
            readyMsg.className = 'log-line';
            readyMsg.style.background = "#d4edda";
            readyMsg.style.color = "#155724";
            readyMsg.style.padding = "5px";
            readyMsg.textContent = `‚úÖ Using cached token - Ready to execute queries`;
            logContent.appendChild(readyMsg);
            return;
        }
        
        // No cached token, try authentication (will attempt client_credentials if no username/password)
        const result = await window.api.tryAuthenticate();
        
        if (result.success) {
            // Authentication successful
            const readyMsg = document.createElement('div');
            readyMsg.className = 'log-line';
            readyMsg.style.background = "#d4edda";
            readyMsg.style.color = "#155724";
            readyMsg.style.padding = "5px";
            const method = result.method === 'client_credentials' ? 'client credentials' : 'password';
            readyMsg.textContent = `‚úÖ Authenticated with ${method} - Ready to execute queries`;
            logContent.appendChild(readyMsg);
        } else if (result.needsOAuth) {
            // Client credentials failed, need OAuth
            const infoMsg = document.createElement('div');
            infoMsg.className = 'log-line';
            infoMsg.style.background = "#d1ecf1";
            infoMsg.style.color = "#0c5460";
            infoMsg.style.padding = "5px";
            infoMsg.textContent = 'üîê Client credentials not available, starting OAuth flow...';
            logContent.appendChild(infoMsg);
            
            // Start OAuth flow
            const oauthResult = await window.api.startOAuthFlow();
            
            if (!oauthResult.success) {
                throw new Error(oauthResult.error);
            }
            
            // Store the actual redirect URI that was used
            currentRedirectUri = oauthResult.redirectUri;
            
            // Warn if using non-default port
            if (!currentRedirectUri.includes(':8888/')) {
                const portWarning = document.createElement('div');
                portWarning.className = 'log-line';
                portWarning.style.background = "#fff3cd";
                portWarning.style.color = "#856404";
                portWarning.style.padding = "5px";
                portWarning.style.fontWeight = "bold";
                portWarning.textContent = `‚ö†Ô∏è Using ${currentRedirectUri} - Make sure ALL ports (8888-8892) are configured in your Salesforce External Client App!`;
                logContent.appendChild(portWarning);
            }
            
            const waitingMsg = document.createElement('div');
            waitingMsg.className = 'log-line';
            waitingMsg.style.background = "#fff3cd";
            waitingMsg.style.color = "#856404";
            waitingMsg.style.padding = "5px";
            waitingMsg.textContent = '‚è≥ Please authenticate in your browser...';
            logContent.appendChild(waitingMsg);
        } else {
            // Some other error
            throw new Error(result.error || 'Authentication failed');
        }
    } catch (error) {
        const errorMsg = document.createElement('div');
        errorMsg.className = 'log-line';
        errorMsg.style.background = "#f8d7da";
        errorMsg.style.color = "#721c24";
        errorMsg.style.padding = "5px";
        errorMsg.textContent = `‚ùå Authentication Error: ${error.message}`;
        logContent.appendChild(errorMsg);
    }
}

// Setup OAuth callback handlers
if (window.api?.onOAuthCallback) {
    window.api.onOAuthCallback(async (authCode) => {
        const log = document.getElementById('logContent');
        
        try {
            const exchangeMsg = document.createElement('div');
            exchangeMsg.className = 'log-line';
            exchangeMsg.style.background = "#d1ecf1";
            exchangeMsg.style.color = "#0c5460";
            exchangeMsg.style.padding = "5px";
            exchangeMsg.textContent = 'üîÑ Exchanging authorization code for access token...';
            logContent.appendChild(exchangeMsg);
            
            if (!currentRedirectUri) {
                throw new Error('Redirect URI not found. Please restart the OAuth flow.');
            }
            
            const result = await window.api.exchangeAuthCode(authCode, currentRedirectUri);
            
            if (result.success) {
                const successMsg = document.createElement('div');
                successMsg.className = 'log-line';
                successMsg.style.background = "#d4edda";
                successMsg.style.color = "#155724";
                successMsg.style.padding = "5px";
                successMsg.textContent = '‚úÖ OAuth authentication successful! You can now execute queries.';
                logContent.appendChild(successMsg);
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            const errorMsg = document.createElement('div');
            errorMsg.className = 'log-line';
            errorMsg.style.background = "#f8d7da";
            errorMsg.style.color = "#721c24";
            errorMsg.style.padding = "5px";
            errorMsg.textContent = `‚ùå Token Exchange Error: ${error.message}`;
            logContent.appendChild(errorMsg);
        }
    });
}

if (window.api?.onOAuthError) {
    window.api.onOAuthError((error) => {
        const log = document.getElementById('logContent');
        const errorMsg = document.createElement('div');
        errorMsg.className = 'log-line';
        errorMsg.style.background = "#f8d7da";
        errorMsg.style.color = "#721c24";
        errorMsg.style.padding = "5px";
        errorMsg.textContent = `‚ùå OAuth Error: ${error.error} - ${error.error_description || 'Unknown error'}`;
        logContent.appendChild(errorMsg);
    });
}

// Session save/load
function saveSession() {
    if (!editorView) return;
    const now = new Date();
    const timestamp = now.getFullYear() + '-' + 
        String(now.getMonth() + 1).padStart(2, '0') + '-' + 
        String(now.getDate()).padStart(2, '0') + 'T' + 
        String(now.getHours()).padStart(2, '0') + '-' + 
        String(now.getMinutes()).padStart(2, '0') + '-' + 
        String(now.getSeconds()).padStart(2, '0');
    const blob=new Blob([editorView.state.doc.toString()],{type:'text/plain'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`soql-session-${timestamp}.txt`; a.click(); URL.revokeObjectURL(a.href);
}
function loadSession(e){
    if (!editorView) return;
    const file=e.target.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=function(ev){
        editorView.dispatch({
            changes: { from: 0, to: editorView.state.doc.length, insert: ev.target.result }
        });
        logContent.innerHTML=''; const msg=document.createElement('div');
        msg.className='log-line'; msg.style.background="#d4edda"; msg.style.color="#155724"; msg.style.padding="5px";
        msg.textContent=`‚úÖ Session loaded from ${file.name}`;
        logContent.appendChild(msg);
        
        // Pre-fetch fields for objects in loaded session
        initAutocomplete();
    }; reader.readAsText(file); e.target.value='';
}

// Splitter (fixed version using flex-basis)
const splitter = document.getElementById("splitter"),
      topDiv = document.getElementById("top"),
      bottomDiv = document.getElementById("bottom");

let isDragging = false;

splitter.addEventListener("mousedown", () => {
    isDragging = true;
    document.body.style.cursor = "row-resize";
    topDiv.style.flex = "none";
    bottomDiv.style.flex = "none";
});

document.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const offsetY = e.clientY;
    const toolbarHeight = document.getElementById("toolbar").offsetHeight;
    const totalHeight = window.innerHeight - toolbarHeight - splitter.offsetHeight;

    const topHeight = Math.max(50, offsetY - toolbarHeight);
    const bottomHeight = Math.max(50, totalHeight - (offsetY - toolbarHeight));

    topDiv.style.height = `${topHeight}px`;
    bottomDiv.style.height = `${bottomHeight}px`;
});

document.addEventListener("mouseup", () => {
    if (!isDragging) return;
    isDragging = false;
    document.body.style.cursor = "default";
});

// Handle window resize to adjust panel heights proportionally
window.addEventListener("resize", () => {
    // Only adjust if panels have fixed heights (splitter has been used)
    if (topDiv.style.height && bottomDiv.style.height) {
        const toolbarHeight = document.getElementById("toolbar").offsetHeight;
        const totalHeight = window.innerHeight - toolbarHeight - splitter.offsetHeight;
        
        // Get current heights
        const currentTopHeight = parseInt(topDiv.style.height);
        const currentBottomHeight = parseInt(bottomDiv.style.height);
        const currentTotal = currentTopHeight + currentBottomHeight;
        
        // Calculate proportions
        const topRatio = currentTopHeight / currentTotal;
        
        // Apply proportional heights
        const newTopHeight = Math.max(50, totalHeight * topRatio);
        const newBottomHeight = Math.max(50, totalHeight - newTopHeight);
        
        topDiv.style.height = `${newTopHeight}px`;
        bottomDiv.style.height = `${newBottomHeight}px`;
    }
});

// Initialize CodeMirror editor
let editorView = null;
const log = document.getElementById("log");
const logContent = document.getElementById("logContent");

// Format Salesforce error messages for better readability
function formatErrorMessage(errorMessage) {
    // Try to extract REST API error details
    const restErrorMatch = errorMessage.match(/REST API error: \[(.*?)\](?:\s*URL:\s*(.*))?$/s);
    if (restErrorMatch) {
        try {
            const errors = JSON.parse('[' + restErrorMatch[1] + ']');
            if (errors && errors.length > 0) {
                const error = errors[0];
                let formatted = '‚ùå <strong>REST API Error</strong>';
                
                // Show error code and message
                if (error.errorCode) {
                    formatted += '<br><strong>' + error.errorCode + ':</strong> ';
                } else {
                    formatted += '<br>';
                }
                
                if (error.message) {
                    formatted += error.message;
                }
                
                // Show URL if present
                if (restErrorMatch[2]) {
                    formatted += '<br><span style="color:#666;font-size:12px">URL: ' + restErrorMatch[2].trim() + '</span>';
                }
                
                return formatted;
            }
        } catch (e) {
            // If parsing fails, fall through to default handling
        }
    }
    
    // Try to extract Salesforce SOQL error details
    const soqlErrorMatch = errorMessage.match(/Salesforce SOQL error: \[(.*)\]$/s);
    if (soqlErrorMatch) {
        try {
            const errors = JSON.parse('[' + soqlErrorMatch[1] + ']');
            if (errors && errors.length > 0) {
                const error = errors[0];
                let formatted = '‚ùå <strong>SOQL Error</strong>';
                
                // Extract the error message, removing the query part if present
                if (error.message) {
                    const messageParts = error.message.split('ERROR at');
                    if (messageParts.length > 1) {
                        // Show the error location
                        const locationPart = 'ERROR at' + messageParts[1].split('\n')[0];
                        formatted += '<br><span style="color:#666">' + locationPart + '</span>';
                        
                        // Show the actual error message (everything after the location line)
                        const errorLines = messageParts[1].split('\n').slice(1).join('\n').trim();
                        if (errorLines) {
                            formatted += '<br>' + errorLines.replace(/\n/g, '<br>');
                        }
                    } else {
                        // No location info, just show the message
                        formatted += '<br>' + error.message.trim().replace(/\n/g, '<br>');
                    }
                }
                
                // Show error code if present
                if (error.errorCode) {
                    formatted += '<br><span style="color:#999;font-size:12px">Code: ' + error.errorCode + '</span>';
                }
                
                return formatted;
            }
        } catch (e) {
            // If parsing fails, fall through to default handling
        }
    }
    
    // Try to extract other IPC errors
    const ipcMatch = errorMessage.match(/Error invoking remote method '([^']+)':\s*Error:\s*(.*)/s);
    if (ipcMatch) {
        return formatErrorMessage(ipcMatch[2]); // Recursively format the inner error
    }
    
    // Default: just return the message with line breaks
    return '‚ùå ' + errorMessage.replace(/\n/g, '<br>');
}

// Copy button
document.getElementById('copyResultsBtn').addEventListener('click',()=>{ 
    if(!log.innerText) return; 
    const btn = document.getElementById('copyResultsBtn');
    navigator.clipboard.writeText(log.innerText)
        .then(() => {
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        })
        .catch(err=>alert('‚ùå Failed to copy results')); 
});

// Ctrl+A in log - select all results content
log.addEventListener('keydown',e=>{ 
    if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='a'){ 
        e.preventDefault(); 
        const r=document.createRange(); 
        r.selectNodeContents(log); 
        const s=window.getSelection(); 
        s.removeAllRanges(); 
        s.addRange(r); 
    } 
});

// Auto-focus log when clicked
log.addEventListener('click', () => log.focus());

// Global Escape handler to close search boxes or stop query
document.addEventListener('keydown', e => {
    if(e.key === 'Escape') {
        const logSearch = document.getElementById('logSearch');
        const helpModal = document.getElementById('helpModal');
        
        // Priority 1: Close help modal if open
        if(helpModal.style.display === 'flex') {
            toggleHelp();
        }
        // Priority 2: Close search box if open
        else if(logSearch.style.display === 'block') {
            closeSearch('log');
        }
        // Priority 3: Stop running query if no popups are open
        else if(currentQueryId) {
            stopQuery();
        }
    }
});

// Search functionality
let currentMatches = {};
let currentMatchIndex = {};

function openSearch(pane) {
    const searchBox = document.getElementById(pane === 'editor' ? 'editorSearch' : 'logSearch');
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    searchBox.style.display = 'block';
    input.focus();
}

function closeSearch(pane) {
    const searchBox = document.getElementById(pane === 'editor' ? 'editorSearch' : 'logSearch');
    searchBox.style.display = 'none';
    clearHighlights(pane);
}

function clearHighlights(pane) {
    if(pane === 'log') {
        // For log, remove highlight spans
        const highlights = logContent.querySelectorAll('.search-highlight, .search-current');
        highlights.forEach(span => {
            const parent = span.parentNode;
            parent.replaceChild(document.createTextNode(span.textContent), span);
            parent.normalize();
        });
        document.getElementById('logMatchCount').textContent = '';
    }
    currentMatches[pane] = [];
    currentMatchIndex[pane] = -1;
}

function findInLog(searchText, direction = 1) {
    if(!searchText) return;
    
    // Only rebuild matches if search text changed
    if(!currentMatches['log'] || currentMatches['log'].searchText !== searchText) {
        clearHighlights('log');
        const text = logContent.textContent;
        const regex = new RegExp(escapeRegex(searchText), 'gi');
        let match;
        const matches = [];
        
        while((match = regex.exec(text)) !== null) {
            matches.push({start: match.index, end: match.index + match[0].length});
        }
        
        if(matches.length === 0) return;
        
        currentMatches['log'] = { matches: matches, searchText: searchText };
        currentMatchIndex['log'] = 0;
    } else {
        // Navigate through existing matches
        const matches = currentMatches['log'].matches;
        currentMatchIndex['log'] += direction;
        if(currentMatchIndex['log'] >= matches.length) currentMatchIndex['log'] = 0;
        if(currentMatchIndex['log'] < 0) currentMatchIndex['log'] = matches.length - 1;
    }
    
    highlightLogMatches(searchText, currentMatchIndex['log']);
    
    // Update match counter
    const counter = document.getElementById('logMatchCount');
    const matches = currentMatches['log'].matches;
    counter.textContent = `${currentMatchIndex['log'] + 1} of ${matches.length}`;
}

function highlightLogMatches(searchText, currentIndex) {
    // Check if highlights already exist
    const existingHighlights = logContent.querySelectorAll('.search-highlight, .search-current');
    
    if(existingHighlights.length === 0) {
        // First time highlighting - walk through text nodes only
        const regex = new RegExp(escapeRegex(searchText), 'gi');
        let matchIndex = 0;
        
        function highlightTextNode(node) {
            if(node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent;
                const matches = [];
                let match;
                regex.lastIndex = 0;
                while((match = regex.exec(text)) !== null) {
                    matches.push({ start: match.index, end: match.index + match[0].length, text: match[0] });
                }
                
                if(matches.length > 0) {
                    const fragment = document.createDocumentFragment();
                    let lastEnd = 0;
                    
                    matches.forEach(m => {
                        if(m.start > lastEnd) {
                            fragment.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
                        }
                        
                        const span = document.createElement('span');
                        span.className = matchIndex === currentIndex ? 'search-current' : 'search-highlight';
                        if(matchIndex === currentIndex) {
                            span.id = 'current-search-match';
                        }
                        span.textContent = m.text;
                        fragment.appendChild(span);
                        
                        lastEnd = m.end;
                        matchIndex++;
                    });
                    
                    if(lastEnd < text.length) {
                        fragment.appendChild(document.createTextNode(text.substring(lastEnd)));
                    }
                    
                    node.parentNode.replaceChild(fragment, node);
                }
            } else if(node.nodeType === Node.ELEMENT_NODE) {
                // Skip search highlight spans
                if(!node.classList.contains('search-highlight') && !node.classList.contains('search-current')) {
                    Array.from(node.childNodes).forEach(child => highlightTextNode(child));
                }
            }
        }
        
        highlightTextNode(logContent);
    } else {
        // Update existing highlights - just change classes
        existingHighlights.forEach((span, index) => {
            span.className = index === currentIndex ? 'search-current' : 'search-highlight';
            if(index === currentIndex) {
                span.id = 'current-search-match';
            } else {
                span.removeAttribute('id');
            }
        });
    }
    
    // Scroll to current match
    setTimeout(() => {
        const currentMatch = document.getElementById('current-search-match');
        if(currentMatch) {
            currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        }
    }, 10);
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findNext(pane) {
    if (pane === 'log') {
        const input = document.getElementById('logSearchInput');
        const searchText = input.value.trim();
        if(searchText) findInLog(searchText, 1);
    }
}

function findPrev(pane) {
    if (pane === 'log') {
        const input = document.getElementById('logSearchInput');
        const searchText = input.value.trim();
        if(searchText) findInLog(searchText, -1);
    }
}

// Ctrl+F handler for log (editor uses built-in CodeMirror search)
log.addEventListener('keydown', e => {
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearch('log');
    }
});

// Search input handlers (log only, editor uses CodeMirror's built-in search)
document.getElementById('logSearchInput').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
        e.preventDefault();
        if(e.shiftKey) {
            findPrev('log');
        } else {
            findNext('log');
        }
    } else if(e.key === 'Escape') {
        closeSearch('log');
    }
});

document.getElementById('logSearchInput').addEventListener('input', e => {
    const searchText = e.target.value.trim();
    if(searchText && searchText.length >= 2) {
        currentMatches['log'] = null; // Reset to trigger new search
        findInLog(searchText, 1);
    } else {
        clearHighlights('log');
    }
});

// Global variables to track current query and table for progressive rendering
let currentQueryId = null;
let currentTable = null;
let currentTbody = null;
let queryStartTime = null;
let queryTimerInterval = null;

// Stop query function
async function stopQuery() {
    if (!currentQueryId) return;
    
    try {
        console.log('Stopping query:', currentQueryId);
        await window.api.abortQuery(currentQueryId);
        
        // Clear live timer
        if (queryTimerInterval) {
            clearInterval(queryTimerInterval);
            queryTimerInterval = null;
        }
        
        currentQueryId = null;
    } catch (error) {
        console.error('Error stopping query:', error);
    }
}

// Helper to get object type from record
function getObjectTypeFromRecord(rec) {
    if (rec.attributes && rec.attributes.type) {
        return rec.attributes.type;
    }
    return null;
}

// Determine object type from an Id field name
function getObjectTypeFromFieldName(fieldName, rec) {
    // For the main "Id" field, use the record's object type
    if (fieldName === 'Id') {
        return getObjectTypeFromRecord(rec);
    }
    
    // For fields ending in "Id", try to determine the object type
    if (fieldName.endsWith('Id')) {
        // Remove "Id" suffix to get potential relationship name
        const baseName = fieldName.slice(0, -2);
        
        // Check if there's a relationship object with the same name
        if (rec[baseName] && typeof rec[baseName] === 'object' && rec[baseName].attributes && rec[baseName].attributes.type) {
            return rec[baseName].attributes.type;
        }
        
        // Try to use cached metadata to determine object type
        const objectType = getObjectTypeFromRecord(rec);
        if (objectType && objectFieldsCache[objectType]) {
            const field = objectFieldsCache[objectType].find(f => f.name === fieldName);
            if (field && field.referenceTo && field.referenceTo.length > 0) {
                // Use the first referenced object type (handles polymorphic fields)
                return field.referenceTo[0];
            }
        }
        
        // Fallback: assume the base name is the object type
        // (e.g., AccountId -> Account, ContactId -> Contact)
        return baseName;
    }
    
    return null;
}

// Add ID click behavior to a cell
function makeIdClickable(td, objectType, idValue) {
    td.style.color = '#0066cc';
    td.style.cursor = 'pointer';
    td.style.textDecoration = 'underline';
    td.style.userSelect = 'text';
    td.title = 'Click to view, Ctrl+Click for Salesforce, or select to copy';
    td.addEventListener('click', (e) => handleIdClick(e, objectType, idValue));
}

// Handle ID cell click
function handleIdClick(event, objectType, idValue) {
    if (!objectType || !idValue) return;
    
    // Check if user is selecting text - if so, don't trigger navigation
    const selection = window.getSelection();
    if (selection && selection.toString().length > 0) {
        return;
    }
    
    if (event.ctrlKey || event.metaKey) {
        // Ctrl+click: Open in Salesforce
        const currentConfig = document.getElementById('envSelector').value;
        if (!currentConfig) {
            alert('No environment selected');
            return;
        }
        // Try to construct Salesforce URL from current connection
        window.api.getCurrentConfig().then(config => {
            if (config && config.instanceUrl) {
                const url = `${config.instanceUrl}/${idValue}`;
                window.api.openExternal(url);
            } else {
                alert('Cannot determine Salesforce URL');
            }
        }).catch(err => {
            console.error('Error getting config:', err);
            alert('Cannot open Salesforce URL');
        });
    } else {
        // Plain click: Execute REST API query in this app
        executeRestForId(objectType, idValue);
    }
}

// Execute REST API query for an ID
// Execute REST API query for an ID
async function executeRestForId(objectType, idValue) {
    try {
        const path = `${objectType}/${idValue}`;
        const res = await window.api.executeREST(path);
        
        // Open result in new window with current conversion state
        await window.api.openResultWindow({ data: res, convertUtcToLocal });
    } catch (err) {
        // Show error in new window
        await window.api.openResultWindow({
            data: { error: err.message || 'Failed to fetch record' },
            convertUtcToLocal
        });
    }
}

// Listen for pagination progress events
if(window.api?.onSOQLProgress) {
    window.api.onSOQLProgress((progress) => {
        console.log('Progress update:', progress);
        
        // Clear the live timer once pagination starts
        if (queryTimerInterval) {
            clearInterval(queryTimerInterval);
            queryTimerInterval = null;
        }
        
        if (!progress.records || progress.records.length === 0) return;
        
        const headers = Object.keys(progress.records[0]).filter(h => h !== "attributes");
        
        // If table doesn't exist yet, create it with first batch
        if (!currentTable || !currentTbody) {
            const headerLabels = headers.map(h => (/^expr\d+$/i.test(h) && headers.length === 1) ? "COUNT" : h);
            const tableEl = document.createElement("table");
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");
            
            // Add row number column header
            const rowNumTh = document.createElement("th");
            rowNumTh.innerHTML = '<span class="filter-toggle-icon" onclick="toggleFilters()" title="Toggle Filters">‚ò∞</span><span class="clear-filters-icon" id="clearFiltersIcon" onclick="clearFilters()" title="Clear Filters">‚Ü∫</span>';
            rowNumTh.style.width = "40px";
            rowNumTh.style.textAlign = "left";
            headerRow.appendChild(rowNumTh);
            
            // Add sortable column headers
            headerLabels.forEach((lbl, idx) => { 
                const th = document.createElement("th"); 
                th.textContent = lbl; 
                th.className = 'sortable';
                th.dataset.columnIndex = idx;
                th.addEventListener('click', () => sortTable(idx, headers[idx], lbl));
                headerRow.appendChild(th); 
            });
            thead.appendChild(headerRow);
            
            // Add filter row
            const filterRow = document.createElement("tr");
            filterRow.className = 'filter-row-hidden'; // Hidden by default
            filterRow.id = 'filterRow';
            
            // Add empty cell for row number column
            const filterRowNumTh = document.createElement("th");
            filterRowNumTh.className = 'filter-row';
            filterRow.appendChild(filterRowNumTh);
            
            // Add filter inputs for each column
            headerLabels.forEach((lbl, idx) => {
                const th = document.createElement("th");
                th.className = 'filter-row';
                const input = document.createElement("input");
                input.type = "text";
                input.className = "filter-input";
                input.placeholder = "Filter...";
                input.dataset.fieldName = headers[idx];
                input.dataset.columnIndex = idx;
                
                // Prevent click from bubbling to sort
                input.addEventListener('click', (e) => e.stopPropagation());
                
                // Filter on input
                input.addEventListener('input', (e) => {
                    columnFilters[headers[idx]] = e.target.value.trim().toLowerCase();
                    applyFilters();
                });
                
                th.appendChild(input);
                filterRow.appendChild(th);
            });
            
            thead.appendChild(filterRow);
            tableEl.appendChild(thead);
            
            const tbody = document.createElement("tbody");
            tableEl.appendChild(tbody);
            logContent.appendChild(tableEl);
            
            currentTable = tableEl;
            currentTbody = tbody;
            
            // Reset sort and filter state for new table
            currentSortColumn = null;
            currentSortDirection = 'asc';
            columnFilters = {};
        }
        
        // Add new rows
        const existingRowCount = currentTbody.children.length;
        const newRecords = progress.records.slice(existingRowCount);
        
        newRecords.forEach((rec, idx) => {
            const tr = document.createElement("tr");
            
            // Add row number cell
            const rowNumTd = document.createElement("td");
            rowNumTd.textContent = existingRowCount + idx + 1;
            rowNumTd.style.textAlign = "right";
            rowNumTd.style.color = "#666";
            tr.appendChild(rowNumTd);
            
            headers.forEach(h => {
                const td = document.createElement("td");
                let val = rec[h];
                if (val === null || val === undefined) td.textContent = "";
                else if (typeof val === "object") {
                    if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                    else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
                } else {
                    // Convert UTC datetime if checkbox is enabled
                    const isDateTime = isUtcDateTime(val);
                    const displayVal = (convertUtcToLocal && isDateTime) ? convertToLocalDateTime(val) : String(val);
                    if (convertUtcToLocal && isDateTime) {
                        console.log('Converting datetime:', val, '->', displayVal);
                    }
                    td.textContent = displayVal;
                    // Make Id fields clickable (Id, AccountId, OwnerId, etc.)
                    if (h.endsWith('Id') && val && val.length === 18) {
                        const objectType = getObjectTypeFromFieldName(h, rec);
                        if (objectType) {
                            makeIdClickable(td, objectType, val);
                        }
                    }
                }
                tr.appendChild(td);
            });
            currentTbody.appendChild(tr);
        });
        
        // Update counter
        if (progress.done) {
            const elapsedMs = Date.now() - queryStartTime;
            const elapsedSec = (elapsedMs / 1000).toFixed(2);
            const totalSize = progress.totalSize || progress.fetchedCount;
            if (totalSize > progress.fetchedCount) {
                document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} of ${totalSize} (${elapsedSec}s)`;
            } else {
                document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} (${elapsedSec}s)`;
            }
        } else {
            const elapsedMs = Date.now() - queryStartTime;
            const elapsedSec = (elapsedMs / 1000).toFixed(1);
            document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} of ${progress.totalSize} (fetching page ${progress.pageNumber}... ${elapsedSec}s)`;
        }
    });
}

// Ctrl+E handler supporting multi-line SOQL separated by blank lines
document.addEventListener("keydown",async e=>{
    if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='e'){
        e.preventDefault(); if(!window.api){ alert("Error: API not loaded."); return; }
        if(!editorView) return;

        // Check if environment is selected
        const envSelector = document.getElementById('envSelector');
        if (!envSelector.value) {
            logContent.innerHTML = '';
            currentResultData = null;
            document.getElementById('exportJsonBtn').style.display = 'none';
            document.getElementById('exportCsvBtn').style.display = 'none';
            showEnvironmentReminder();
            return;
        }

        const text = editorView.state.doc.toString();
        const cursorPos = editorView.state.selection.main.head;

        // Find the block containing the cursor
        const lines = text.split('\n');
        let charPos = 0;
        let blockStart = -1;
        let blockEnd = -1;
        let blockLines = [];
        let inBlock = false;
        
        for(let i = 0; i < lines.length; i++){
            const line = lines[i];
            const lineStart = charPos;
            const lineEnd = charPos + line.length;
            
            if(line.trim() === ''){
                if(inBlock){
                    blockEnd = charPos - 1; // End before the empty line
                    if(cursorPos >= blockStart && cursorPos <= blockEnd) break;
                    blockStart = -1;
                    blockLines = [];
                    inBlock = false;
                }
            } else {
                if(!inBlock){
                    blockStart = lineStart;
                    inBlock = true;
                }
                blockLines.push(line);
                blockEnd = lineEnd;
            }
            charPos += line.length + 1; // +1 for newline
        }
        
        // Check if cursor is in the found block
        if(blockStart === -1 || cursorPos < blockStart || cursorPos > blockEnd){
            return;
        }
        
        const targetBlock = blockLines.map(l => l.trim()).join('\n').trim();
        if(!targetBlock) return;

        // Highlight the block being executed
        editorView.dispatch({
            selection: { anchor: blockStart, head: blockEnd }
        });
        editorView.focus();

        logContent.innerHTML='';
        currentTable = null;
        currentTbody = null;
        currentResultData = null;
        filtersVisible = false; // Reset filter visibility
        document.getElementById('exportJsonBtn').style.display = 'none';
        document.getElementById('exportCsvBtn').style.display = 'none';
        currentQueryId = 'query_' + Date.now();
        queryStartTime = Date.now();
        document.getElementById('resultsCount').textContent = '';
        document.getElementById('stopQueryBtn').style.display = 'inline-block';
        document.getElementById('convertUtcCheckbox').disabled = true;
        
        // Start live timer to show execution progress
        queryTimerInterval = setInterval(() => {
            const elapsedMs = Date.now() - queryStartTime;
            const elapsedSec = (elapsedMs / 1000).toFixed(1);
            document.getElementById('resultsCount').textContent = `Executing... (${elapsedSec}s)`;
        }, 100);
        
        document.body.style.cursor = 'wait';
        try{
            const soqlKeywords=/^(SELECT|UPDATE|DELETE|INSERT|UPSERT|MERGE)\b/i;
            if(soqlKeywords.test(targetBlock)){
                // Remove // and -- comments from SOQL
                const cleanedBlock = targetBlock.split('\n').map(l=>l.replace(/(\/\/|--).*/,'').trim()).join('\n').trim();
                const result = await window.api.executeSOQL(cleanedBlock, currentQueryId);
                
                // Check if query was aborted
                if (result && result.aborted) {
                    const errEl=document.createElement("div"); errEl.className="log-line";
                    errEl.style.background = '#fff3cd';
                    errEl.style.color = '#856404';
                    errEl.innerHTML = '‚èπ Query was stopped';
                    logContent.appendChild(errEl);
                    
                    // If we have partial results from pagination, keep them exportable
                    if (currentTable && currentTbody && currentTbody.children.length > 0) {
                        // Extract partial data from the rendered table for export
                        const rows = Array.from(currentTbody.children);
                        const headerCells = Array.from(currentTable.querySelector('thead tr').children);
                        const headers = headerCells.slice(1).map(th => th.textContent); // Skip row number column
                        
                        const partialRecords = rows.map(row => {
                            const record = {};
                            const cells = Array.from(row.children).slice(1); // Skip row number column
                            headers.forEach((header, idx) => {
                                record[header] = cells[idx].textContent;
                            });
                            return record;
                        });
                        
                        currentResultData = { records: partialRecords, totalSize: partialRecords.length };
                        document.getElementById('exportJsonBtn').style.display = 'inline-block';
                        document.getElementById('exportCsvBtn').style.display = 'inline-block';
                        
                        const elapsedMs = queryStartTime ? Date.now() - queryStartTime : 0;
                        const elapsedSec = (elapsedMs / 1000).toFixed(2);
                        
                        // Show how many were fetched vs total expected
                        const fetchedCount = result.fetchedCount || partialRecords.length;
                        const totalSize = result.totalSize || 0;
                        if (totalSize > fetchedCount) {
                            document.getElementById('resultsCount').textContent = `Results: ${fetchedCount} of ${totalSize} (partial, ${elapsedSec}s)`;
                        } else {
                            document.getElementById('resultsCount').textContent = `Results: ${partialRecords.length} (partial, ${elapsedSec}s)`;
                        }
                    }
                } else {
                    renderResult(result);
                }
            } else {
                // Treat each non-empty line as a REST path
                const lines = targetBlock.split("\n").map(l=>l.trim()).filter(l=>l);
                for(const path of lines){
                    try{
                        // Remove // and -- comments from REST paths
                        const cleanedPath = path.replace(/(\/\/|--).*/,'').trim();
                        if(!cleanedPath) continue;
                        const res = await window.api.executeREST(cleanedPath);
                        renderResult(res);
                    } catch(err){
                        const errEl=document.createElement("div"); errEl.className="log-line";
                        errEl.innerHTML=formatErrorMessage(err.message);
                        logContent.appendChild(errEl);
                    }
                }
            }
        } catch(err){
            const errEl=document.createElement("div"); errEl.className="log-line";
            errEl.innerHTML=formatErrorMessage(err.message);
            logContent.appendChild(errEl);
        }
        
        // Clear live timer
        if (queryTimerInterval) {
            clearInterval(queryTimerInterval);
            queryTimerInterval = null;
        }
        
        document.getElementById('stopQueryBtn').style.display = 'none';
        document.getElementById('convertUtcCheckbox').disabled = false;
        currentQueryId = null;
        document.body.style.cursor = 'default';
        logContent.scrollTop = 0;
    }
});

// Render results helper
function renderResult(result, isRerender = false) {
    let elapsedSec;
    if (isRerender && originalElapsedTime !== null) {
        // Use preserved time when re-rendering
        elapsedSec = originalElapsedTime;
    } else {
        // Calculate and store new elapsed time
        const elapsedMs = queryStartTime ? Date.now() - queryStartTime : 0;
        elapsedSec = (elapsedMs / 1000).toFixed(2);
        originalElapsedTime = elapsedSec;
    }
    
    // Store result data for export
    currentResultData = result;
    
    // Show export buttons if we have exportable data
    // JSON export: always available if we have any result
    const hasAnyData = (result && typeof result === 'object');
    document.getElementById('exportJsonBtn').style.display = hasAnyData ? 'inline-block' : 'none';
    
    // CSV export: only available for records (SOQL results)
    const hasRecords = (result && (result.records || Array.isArray(result)));
    document.getElementById('exportCsvBtn').style.display = hasRecords ? 'inline-block' : 'none';
    
    // If table was already rendered progressively, just update the final counter
    if (currentTable && currentTbody) {
        const records = result.records || result;
        const totalSize = result.totalSize || records.length;
        if (totalSize > records.length) {
            document.getElementById('resultsCount').textContent = `Results: ${records.length} of ${totalSize} (${elapsedSec}s)`;
        } else {
            document.getElementById('resultsCount').textContent = `Results: ${records.length} (${elapsedSec}s)`;
        }
        return;
    }
    
    if (result && result.totalSize !== undefined && (!result.records || result.records.length === 0)) {
        const tableEl = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const th = document.createElement("th"); th.textContent = "COUNT";
        headerRow.appendChild(th); thead.appendChild(headerRow); tableEl.appendChild(thead);
        const tbody = document.createElement("tbody");
        const tr = document.createElement("tr"); const td = document.createElement("td");
        td.textContent = result.totalSize; tr.appendChild(td); tbody.appendChild(tr); tableEl.appendChild(tbody);
        logContent.appendChild(tableEl);
        document.getElementById('resultsCount').textContent = `Results: ${result.totalSize} (${elapsedSec}s)`;
        return;
    }

    if (!result.records && !Array.isArray(result)) {
        const pre = document.createElement("pre");
        // Apply datetime conversion if enabled
        const displayData = convertUtcToLocal ? convertDatetimesInObject(result) : result;
        const jsonString = JSON.stringify(displayData, null, 2);
        pre.textContent = jsonString;
        logContent.appendChild(pre);
        const lineCount = jsonString.split('\n').length;
        document.getElementById('resultsCount').textContent = `Results: JSON Response (${lineCount} lines, ${elapsedSec}s)`;
        return;
    }

    const records = result.records || result;
    if (!records || records.length === 0) {
        const emptyEl = document.createElement("div");
        emptyEl.className = "log-line";
        emptyEl.textContent = "‚ö†Ô∏è No records returned.";
        logContent.appendChild(emptyEl);
        document.getElementById('resultsCount').textContent = `Results: 0 (${elapsedSec}s)`;
        return;
    }

    const headers = Object.keys(records[0]).filter(h => h !== "attributes");
    if (headers.length === 0) {
        const emptyEl = document.createElement("div");
        emptyEl.className = "log-line";
        emptyEl.textContent = "‚ö†Ô∏è No fields to display.";
        logContent.appendChild(emptyEl);
        return;
    }

    const headerLabels = headers.map(h => (/^expr\d+$/i.test(h) && headers.length === 1) ? "COUNT" : h);
    const tableEl = document.createElement("table");
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    
    // Add row number column header
    const rowNumTh = document.createElement("th");
    rowNumTh.innerHTML = '<span class="filter-toggle-icon" onclick="toggleFilters()" title="Toggle Filters">‚ò∞</span><span class="clear-filters-icon" id="clearFiltersIcon" onclick="clearFilters()" title="Clear Filters">‚Ü∫</span>';
    rowNumTh.style.width = "40px";
    rowNumTh.style.textAlign = "left";
    headerRow.appendChild(rowNumTh);
    
    // Add sortable column headers
    headerLabels.forEach((lbl, idx) => { 
        const th = document.createElement("th"); 
        th.textContent = lbl; 
        th.className = 'sortable';
        th.dataset.columnIndex = idx;
        th.addEventListener('click', () => sortTable(idx, headers[idx], lbl));
        headerRow.appendChild(th); 
    });
    thead.appendChild(headerRow);
    
    // Add filter row
    const filterRow = document.createElement("tr");
    filterRow.className = 'filter-row-hidden'; // Hidden by default
    filterRow.id = 'filterRow';
    
    // Add empty cell for row number column
    const filterRowNumTh = document.createElement("th");
    filterRowNumTh.className = 'filter-row';
    filterRow.appendChild(filterRowNumTh);
    
    // Add filter inputs for each column
    headerLabels.forEach((lbl, idx) => {
        const th = document.createElement("th");
        th.className = 'filter-row';
        const input = document.createElement("input");
        input.type = "text";
        input.className = "filter-input";
        input.placeholder = "Filter...";
        input.dataset.fieldName = headers[idx];
        input.dataset.columnIndex = idx;
        
        // Prevent click from bubbling to sort
        input.addEventListener('click', (e) => e.stopPropagation());
        
        // Filter on input
        input.addEventListener('input', (e) => {
            columnFilters[headers[idx]] = e.target.value.trim().toLowerCase();
            applyFilters();
        });
        
        th.appendChild(input);
        filterRow.appendChild(th);
    });
    
    thead.appendChild(filterRow);
    tableEl.appendChild(thead);
    
    // Reset sort and filter state for new table
    currentSortColumn = null;
    currentSortDirection = 'asc';
    columnFilters = {};

    const tbody = document.createElement("tbody");
    
    // Store references for progressive rendering
    currentTable = tableEl;
    currentTbody = tbody;
    records.forEach((rec, index) => {
        const tr = document.createElement("tr");
        
        // Add row number cell
        const rowNumTd = document.createElement("td");
        rowNumTd.textContent = index + 1;
        rowNumTd.style.textAlign = "right";
        rowNumTd.style.color = "#666";
        tr.appendChild(rowNumTd);
        
        headers.forEach(h => {
            const td = document.createElement("td");
            let val = rec[h];
            if (val === null || val === undefined) td.textContent = "";
            else if (typeof val === "object") {
                if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
            } else {
                // Convert UTC datetime if checkbox is enabled
                const isDateTime = isUtcDateTime(val);
                const displayVal = (convertUtcToLocal && isDateTime) ? convertToLocalDateTime(val) : String(val);
                if (convertUtcToLocal && isDateTime) {
                    console.log('Converting datetime (renderResult):', val, '->', displayVal);
                }
                td.textContent = displayVal;
                // Make Id fields clickable (Id, AccountId, OwnerId, etc.)
                if (h.endsWith('Id') && val && val.length === 18) {
                    const objectType = getObjectTypeFromFieldName(h, rec);
                    if (objectType) {
                        makeIdClickable(td, objectType, val);
                    }
                }
            }
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });

    tableEl.appendChild(tbody);
    logContent.appendChild(tableEl);
    
    // Update results counter - show if pagination occurred
    const totalSize = result.totalSize || records.length;
    if (totalSize > records.length) {
        document.getElementById('resultsCount').textContent = `Results: ${records.length} of ${totalSize} (${elapsedSec}s)`;
    } else {
        document.getElementById('resultsCount').textContent = `Results: ${records.length} (${elapsedSec}s)`;
    }
}

// Sort table by column
function sortTable(columnIndex, fieldName, displayName) {
    if (!currentResultData) return;
    
    const records = currentResultData.records || currentResultData;
    if (!records || records.length === 0) return;
    
    // Show sorting indicator
    document.body.style.cursor = 'wait';
    const resultsCount = document.getElementById('resultsCount');
    const originalText = resultsCount.textContent;
    resultsCount.textContent = 'Sorting...';
    
    // Use setTimeout to allow UI to update before heavy sorting
    setTimeout(() => {
        // Toggle sort direction if same column, otherwise reset to ascending
        if (currentSortColumn === columnIndex) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            currentSortColumn = columnIndex;
            currentSortDirection = 'asc';
        }
        
        // Sort records
        records.sort((a, b) => {
        let valA = a[fieldName];
        let valB = b[fieldName];
        
        // Handle nested objects (like relationships)
        if (typeof valA === 'object' && valA !== null) {
            valA = valA.Name || valA.name || JSON.stringify(valA);
        }
        if (typeof valB === 'object' && valB !== null) {
            valB = valB.Name || valB.name || JSON.stringify(valB);
        }
        
        // Handle nulls - always sort to bottom
        if (valA === null || valA === undefined) return 1;
        if (valB === null || valB === undefined) return -1;
        
        // Detect data type and compare
        const numA = Number(valA);
        const numB = Number(valB);
        
        let comparison = 0;
        if (!isNaN(numA) && !isNaN(numB)) {
            // Numeric comparison
            comparison = numA - numB;
        } else {
            // String comparison (case-insensitive)
            const strA = String(valA).toLowerCase();
            const strB = String(valB).toLowerCase();
            comparison = strA.localeCompare(strB);
        }
        
        return currentSortDirection === 'asc' ? comparison : -comparison;
    });
    
    // Re-render table body
    const tbody = currentTbody;
    if (!tbody) return;
    
    // Update header indicators
    const headerRow = currentTable.querySelector('thead tr');
    const ths = headerRow.querySelectorAll('th.sortable');
    ths.forEach((th, idx) => {
        th.classList.remove('sorted', 'asc', 'desc');
        if (idx === columnIndex) {
            th.classList.add('sorted', currentSortDirection);
        }
    });
    
    // Reset cursor and status text
    document.body.style.cursor = 'default';
    resultsCount.textContent = originalText;
    
    // Re-apply filters if any are active to respect filtering after sort
    const activeFilters = Object.keys(columnFilters).filter(key => columnFilters[key]);
    if (activeFilters.length > 0) {
        applyFilters();
    } else {
        // No filters, just render all sorted records
        tbody.innerHTML = '';
        const headers = Object.keys(records[0]).filter(h => h !== "attributes");
        
        records.forEach((rec, index) => {
            const tr = document.createElement("tr");
            
            // Add row number cell
            const rowNumTd = document.createElement("td");
            rowNumTd.textContent = index + 1;
            rowNumTd.style.textAlign = "right";
            rowNumTd.style.color = "#666";
            tr.appendChild(rowNumTd);
            
            headers.forEach(h => {
                const td = document.createElement("td");
                let val = rec[h];
                if (val === null || val === undefined) td.textContent = "";
                else if (typeof val === "object") {
                    if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                    else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
                } else {
                    td.textContent = String(val);
                    // Make Id fields clickable (Id, AccountId, OwnerId, etc.)
                    if (h.endsWith('Id') && val && val.length === 18) {
                        const objectType = getObjectTypeFromFieldName(h, rec);
                        if (objectType) {
                            makeIdClickable(td, objectType, val);
                        }
                    }
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
    }
    }, 10);
}

// Apply filters to table
function applyFilters() {
    if (!currentResultData) return;
    
    const records = currentResultData.records || currentResultData;
    if (!records || records.length === 0) return;
    
    const tbody = currentTbody;
    if (!tbody) return;
    
    // Check if any filters are active
    const activeFilters = Object.keys(columnFilters).filter(key => columnFilters[key]);
    const hasActiveFilters = activeFilters.length > 0;
    
    // Show/hide clear filters icon
    const clearIcon = document.getElementById('clearFiltersIcon');
    if (clearIcon) {
        clearIcon.style.display = hasActiveFilters ? 'inline-block' : 'none';
    }
    
    const headers = Object.keys(records[0]).filter(h => h !== "attributes");
    
    // Filter and re-render rows
    tbody.innerHTML = '';
    let visibleCount = 0;
    
    records.forEach((rec, index) => {
        // Check if record matches all filters
        let matches = true;
        for (const fieldName of activeFilters) {
            const filterValue = columnFilters[fieldName];
            if (!filterValue) continue;
            
            let cellValue = rec[fieldName];
            
            // Handle nested objects
            if (typeof cellValue === 'object' && cellValue !== null) {
                cellValue = cellValue.Name || cellValue.name || JSON.stringify(cellValue);
            }
            
            // Convert to string and check if it includes filter text
            const cellText = String(cellValue || '').toLowerCase();
            if (!cellText.includes(filterValue)) {
                matches = false;
                break;
            }
        }
        
        if (!matches) return; // Skip this row
        
        visibleCount++;
        
        // Create row
        const tr = document.createElement("tr");
        
        // Add row number cell (use original index + 1)
        const rowNumTd = document.createElement("td");
        rowNumTd.textContent = index + 1;
        rowNumTd.style.textAlign = "right";
        rowNumTd.style.color = "#666";
        tr.appendChild(rowNumTd);
        
        headers.forEach(h => {
            const td = document.createElement("td");
            let val = rec[h];
            if (val === null || val === undefined) td.textContent = "";
            else if (typeof val === "object") {
                if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
            } else {
                td.textContent = String(val);
                // Make Id fields clickable (Id, AccountId, OwnerId, etc.)
                if (h.endsWith('Id') && val && val.length === 18) {
                    const objectType = getObjectTypeFromFieldName(h, rec);
                    if (objectType) {
                        makeIdClickable(td, objectType, val);
                    }
                }
            }
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });
    
    // Update results count
    const totalSize = currentResultData.totalSize || records.length;
    const elapsedMs = queryStartTime ? Date.now() - queryStartTime : 0;
    const elapsedSec = (elapsedMs / 1000).toFixed(2);
    
    if (hasActiveFilters) {
        document.getElementById('resultsCount').textContent = 
            `Results: ${visibleCount} of ${records.length} (filtered) (${elapsedSec}s)`;
    } else if (totalSize > records.length) {
        document.getElementById('resultsCount').textContent = 
            `Results: ${records.length} of ${totalSize} (${elapsedSec}s)`;
    } else {
        document.getElementById('resultsCount').textContent = 
            `Results: ${records.length} (${elapsedSec}s)`;
    }
}

// Clear all filters
function clearFilters() {
    columnFilters = {};
    
    // Clear all filter inputs
    if (currentTable) {
        const filterInputs = currentTable.querySelectorAll('.filter-input');
        filterInputs.forEach(input => input.value = '');
    }
    
    // Re-render table without filters
    applyFilters();
}

// Toggle filter row visibility
function toggleFilters() {
    filtersVisible = !filtersVisible;
    
    const filterRow = document.getElementById('filterRow');
    const icons = document.querySelectorAll('.filter-toggle-icon');
    
    if (filterRow) {
        if (filtersVisible) {
            filterRow.classList.remove('filter-row-hidden');
            icons.forEach(icon => icon.classList.add('active'));
        } else {
            filterRow.classList.add('filter-row-hidden');
            icons.forEach(icon => icon.classList.remove('active'));
        }
    }
}

// ===== AUTOCOMPLETE FUNCTIONS =====

// Fetch and cache all SObjects
// Fetch and cache SObjects list
// Exposed globally for CodeMirror autocomplete
window.fetchSObjects = async function() {
    if (sobjectsCache) return sobjectsCache;
    try {
        const result = await window.api.describeGlobal();
        sobjectsCache = result.sobjects || [];
        console.log('Cached', sobjectsCache.length, 'SObjects');
        return sobjectsCache;
    } catch (error) {
        console.error('Error fetching SObjects:', error);
        // Check if it's a config error
        if (error.message && error.message.includes('No config selected')) {
            showEnvironmentReminder();
        }
        return [];
    }
}

// Fetch and cache fields for a specific object
// Exposed globally for CodeMirror autocomplete
window.fetchObjectFields = async function(objectName) {
    // Normalize to title case for cache lookup
    const normalizedName = objectName.charAt(0).toUpperCase() + objectName.slice(1).toLowerCase();
    
    if (objectFieldsCache[normalizedName]) return objectFieldsCache[normalizedName];
    try {
        const result = await window.api.describeObject(normalizedName);
        
        // Process fields to identify relationships
        const processedFields = (result.fields || []).map(field => {
            const isRelationship = field.type === 'reference' && field.relationshipName;
            return {
                ...field,
                isRelationship: isRelationship,
                relationshipName: field.relationshipName || null,
                referenceTo: field.referenceTo || []
            };
        });
        
        objectFieldsCache[normalizedName] = processedFields;
        console.log('Cached', processedFields.length, 'fields for', normalizedName);
        return processedFields;
    } catch (error) {
        console.error('Error fetching fields for', normalizedName, ':', error);
        // Check if it's a config error
        if (error.message && error.message.includes('No config selected')) {
            showEnvironmentReminder();
        }
        return [];
    }
}

// Show reminder to select environment
function showEnvironmentReminder() {
    const logContent = document.getElementById('logContent');
    
    // Check if reminder is already displayed
    const existingReminder = logContent.querySelector('.env-reminder');
    if (existingReminder) return;
    
    const msg = document.createElement('div');
    msg.className = 'log-line env-reminder';
    msg.style.background = '#fff3cd';
    msg.style.color = '#856404';
    msg.style.padding = '5px';
    msg.textContent = '‚ö†Ô∏è Please select an environment first';
    logContent.appendChild(msg);
}

// Parse query context to determine what to suggest
// Exposed globally for CodeMirror autocomplete
window.getAutocompleteContext = function(text, cursorPos) {
    // Get text before and after cursor
    const textBeforeCursor = text.substring(0, cursorPos);
    const textAfterCursor = text.substring(cursorPos);
    const textBeforeCursorUpper = textBeforeCursor.toUpperCase();
    
    // Get current word being typed
    const wordMatch = textBeforeCursor.match(/[\w\.]+$/);
    let currentWord = wordMatch ? wordMatch[0] : '';
    
    // If typing right before a keyword, strip it from currentWord
    if (textAfterCursor.match(/^(FROM|WHERE|ORDER|GROUP|LIMIT)\b/i)) {
        const keywordMatch = currentWord.match(/^(.*?)(FROM|WHERE|ORDER|GROUP|LIMIT)$/i);
        if (keywordMatch) {
            currentWord = keywordMatch[1];
        }
    }
    
    // ===== KEYWORD SUPPRESSION =====
    // Suppress autocomplete when user is typing SOQL keywords themselves
    
    const currentWordUpper = currentWord.toUpperCase();
    const textBeforeWord = textBeforeCursorUpper.substring(0, textBeforeCursorUpper.length - currentWord.length);
    
    // Suppress when typing "BY" after ORDER/GROUP
    if (textBeforeCursorUpper.match(/\b(ORDER|GROUP)\s+B[Y]?$/i)) {
        return null;
    }
    
    // Suppress ORDER/GROUP keywords after FROM clause (e.g., "SELECT Id FROM Account Ord")
    if (currentWordUpper.match(/^(ORD|ORDE|ORDER|GRO|GROU|GROUP)$/) && textBeforeWord.match(/\bFROM\s+\w+/i)) {
        return null;
    }
    
    // Suppress general SQL keywords at start of query or after clause keywords
    const isTypingKeyword = currentWordUpper.match(/^(SEL|SELE|SELEC|SELECT|FRO|FROM|WH|WHE|WHER|WHERE|ORD|ORDE|ORDER|GRO|GROU|GROUP|LIM|LIMI|LIMIT|B|BY)$/);
    if (isTypingKeyword && (textBeforeWord.match(/^\s*$/) || textBeforeWord.match(/\b(SELECT|WHERE|AND|OR|NOT|FROM)\s*$/i))) {
        return null;
    }
    
    // ===== OBJECT NAME DETECTION =====
    // Extract current query block and find the object name from FROM clause
    
    let blockStart = 0;
    for (let i = cursorPos - 1; i >= 0; i--) {
        if (text[i] === '\n' && (i === 0 || text[i-1] === '\n')) {
            blockStart = i + 1;
            break;
        }
    }
    let blockEnd = text.length;
    for (let i = cursorPos; i < text.length; i++) {
        if (text[i] === '\n' && (i === text.length - 1 || text[i+1] === '\n')) {
            blockEnd = i;
            break;
        }
    }
    const queryBlock = text.substring(blockStart, blockEnd).toUpperCase();
    
    // Find object name from FROM clause (look ahead and in current block)
    const fromMatchAhead = textAfterCursor.toUpperCase().match(/^FROM\s+(\w+)/);
    const fromMatchInBlock = queryBlock.match(/\bFROM\s+(\w+)/);
    const objectName = fromMatchAhead ? fromMatchAhead[1] : (fromMatchInBlock ? fromMatchInBlock[1] : null);
    
    // If typing the object name after FROM, suggest objects
    if (textBeforeCursorUpper.match(/\bFROM\s*(\w*)$/)) {
        return { type: 'object', prefix: currentWord };
    }
    
    // ===== RELATIONSHIP FIELD DETECTION =====
    // Check if typing a relationship field (e.g., Account.Name or Account.Owner.Name)
    
    if (currentWord.includes('.')) {
        const parts = currentWord.split('.');
        
        // Single level: Account.Name
        if (parts.length === 2) {
            const relationshipName = parts[0];
            const fieldPrefix = parts[1];
            
            // We need the base object's fields to find the relationship
            if (objectName) {
                return {
                    type: 'relationship-field',
                    baseObjectName: objectName,
                    relationshipName: relationshipName,
                    prefix: fieldPrefix
                };
            }
        }
        
        // Multi-level: Account.Owner.Name (need to traverse the relationship chain)
        if (parts.length > 2 && objectName) {
            return {
                type: 'multi-relationship-field',
                baseObjectName: objectName,
                relationshipPath: parts.slice(0, -1), // All parts except the last
                prefix: parts[parts.length - 1] // Last part is the prefix
            };
        }
    }
    
    // ===== CLAUSE DETECTION =====
    // Determine which SOQL clause we're in and whether to suggest fields
    
    if (objectName) {
        const selectMatch = textBeforeCursorUpper.match(/\bSELECT\b(.*)$/);
        const whereMatch = textBeforeCursorUpper.match(/\bWHERE\b(.*)$/);
        const orderByMatch = textBeforeCursorUpper.match(/\bORDER\s+BY\b(.*)$/);
        const groupByMatch = textBeforeCursorUpper.match(/\bGROUP\s+BY\b(.*)$/);
        
        // SELECT clause - suggest fields before FROM or if FROM is ahead
        if (selectMatch && (!selectMatch[1].includes('FROM') || fromMatchAhead)) {
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
        
        // ORDER BY clause - handle comma-separated fields and ASC/DESC keywords
        if (orderByMatch) {
            const textAfterOrderBy = orderByMatch[1];
            const textBeforeWord = textAfterOrderBy.substring(0, textAfterOrderBy.length - currentWord.length);
            
            // After comma - show field suggestions
            if (textBeforeWord.match(/,\s*$/)) {
                return { type: 'field', objectName: objectName, prefix: currentWord };
            }
            
            // Typing ASC/DESC - suppress
            if (currentWord.toLowerCase().match(/^(a|as|asc|d|de|des|desc)$/)) {
                return null;
            }
            
            // After field name with space (before ASC/DESC) - suppress
            if (textBeforeWord.match(/\w\s+$/) && currentWord === '') {
                return null;
            }
            
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
        
        // WHERE clause - handle operators, values, quotes, and logical operators
        if (whereMatch) {
            const textAfterWhere = whereMatch[1];
            const textBeforeWord = textAfterWhere.substring(0, textAfterWhere.length - currentWord.length);
            
            // After closing quote - suppress until AND/OR typed
            if (textBeforeWord.match(/['"]\s*$/) && currentWord === '') {
                return null;
            }
            
            // After comparison operator - suppress (user is typing a value)
            if (textAfterWhere.match(/(=|!=|<|>|<=|>=|\bLIKE|\bIN|\bNOT\s+IN)\s*['"]?[\w\s]*$/i)) {
                return null;
            }
            
            // Typing logical operators (AND/OR/NOT) after a condition - suppress
            const hasLogicalKeywordBefore = textBeforeWord.match(/\b(AND|OR|NOT)\s+$/i);
            if (!hasLogicalKeywordBefore && currentWord.toLowerCase().match(/^(a|an|and|o|or|n|no|not)$/i)) {
                if (textBeforeWord.trim().match(/(['"\d\w]\s*$|\)\s*$)/)) {
                    return null;
                }
            }
            
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
        
        // GROUP BY clause - suggest fields
        if (groupByMatch) {
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
    }
    return null;
}

// Initialize autocomplete
function initAutocomplete() {
    // Pre-fetch fields for objects found in current editor content
    if (editorView) {
        const text = editorView.state.doc.toString();
        const fromMatches = text.matchAll(/\bFROM\s+(\w+)/gi);
        const objectNames = new Set();
        for (const match of fromMatches) {
            objectNames.add(match[1]);
        }
        
        // Fetch fields in background for each object
        objectNames.forEach(objName => {
            window.fetchObjectFields(objName).catch(err => 
                console.log('Background fetch failed for', objName, ':', err.message)
            );
        });
    }
}

document.addEventListener('DOMContentLoaded',()=>{ 
    // Initialize CodeMirror editor
    if (window.createCodeMirrorEditor) {
        const editorContainer = document.getElementById("editor");
        editorView = window.createCodeMirrorEditor(editorContainer);
    } else {
        console.error('CodeMirror editor not available');
    }
    
    // Load environments
    loadEnvironments();
    initAutocomplete();
});
</script>
</body>
</html>

