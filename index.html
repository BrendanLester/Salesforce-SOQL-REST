<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Playforce Query</title>
<style>
body { margin:0; height:100vh; display:flex; flex-direction:column; font-family:sans-serif; }
#toolbar { display:flex; gap:10px; padding:8px; background:#e8e8e8; border-bottom:1px solid #ccc; }
#toolbar button { padding:6px 12px; background:#0066cc; color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px; }
#toolbar button:hover { background:#0052a3; }
#toolbar input[type="file"] { display:none; }
#top, #bottom { flex:1; overflow:hidden; }
#splitter { height:5px; background:#888; cursor:row-resize; }
textarea { width:100%; height:100%; resize:none; font-family:monospace; font-size:14px; box-sizing:border-box; padding:8px; overflow:auto; }
textarea::selection { background:#ffd700; color:#000; }
#log { padding:8px; font-family:monospace; font-size:14px; overflow:auto; flex:1; outline:none; }
#log:focus { box-shadow: inset 0 0 0 2px #0066cc; }
.log-line { padding:2px 0; border-bottom:1px solid #ccc; }
table { width:100%; border-collapse:collapse; margin-top:4px; font-family:monospace; font-size:14px; }
th, td { border:1px solid #ccc; padding:4px 8px; text-align:left; }
th { background:#eee; }
tr:nth-child(even) { background:#f9f9f9; }
tr:hover { background:#fffae6; }
.keyword { color:#d73a49; font-weight:bold; }

#results-header { display:flex; justify-content:flex-end; align-items:center; gap:8px; padding:4px 8px; border-bottom:1px solid #ccc; background:#f5f5f5; }
#copyResultsBtn { padding:4px 8px; font-size:12px; cursor:pointer; }
#stopQueryBtn { padding:4px 8px; font-size:12px; cursor:pointer; background:#dc3545; color:white; border:none; border-radius:4px; display:none; }
#stopQueryBtn:hover { background:#c82333; }
#exportJsonBtn, #exportCsvBtn { padding:4px 8px; font-size:12px; cursor:pointer; }

.search-box { position:absolute; top:10px; right:10px; background:#fff; border:2px solid #0066cc; border-radius:4px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:1000; display:none; }
.search-box input { border:1px solid #ccc; padding:4px; margin-right:4px; font-size:12px; }
.search-box button { background:#0066cc; color:white; border:none; padding:4px 8px; cursor:pointer; font-size:12px; }
.search-box button:hover { background:#0052a3; }
.search-highlight { background:#ffff00; color:#000; }
.search-current { background:#ff6600; color:#fff; }

#autocomplete { position:fixed; background:#fff; border:1px solid #0066cc; border-radius:4px; box-shadow:0 4px 8px rgba(0,0,0,0.2); max-height:200px; overflow-y:auto; z-index:9999; display:none; min-width:150px; }
.autocomplete-item { padding:6px 12px; cursor:pointer; font-family:monospace; font-size:13px; }
.autocomplete-item:hover { background:#e6f2ff; }
.autocomplete-item.selected { background:#0066cc; color:white; }
.autocomplete-hint { font-size:11px; color:#888; margin-left:8px; }
.autocomplete-relationship { color:#0066cc; font-weight:bold; }
#autocompleteToggle { margin-left:20px; display:flex; align-items:center; gap:4px; font-size:12px; color:#666; }
#autocompleteToggle input[type="checkbox"] { cursor:pointer; }

#helpModal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:10000; display:none; align-items:center; justify-content:center; }
#helpContent { background:#fff; border-radius:8px; padding:20px; max-width:400px; box-shadow:0 4px 16px rgba(0,0,0,0.3); }
#helpContent h3 { margin:0 0 15px 0; color:#333; border-bottom:2px solid #0066cc; padding-bottom:8px; }
#helpContent table { width:100%; border-collapse:collapse; font-family:monospace; font-size:13px; }
#helpContent td { padding:6px 8px; border-bottom:1px solid #eee; }
#helpContent td:first-child { font-weight:bold; color:#0066cc; white-space:nowrap; }
#helpContent td:last-child { color:#666; }
#helpClose { float:right; background:#0066cc; color:white; border:none; padding:4px 12px; border-radius:4px; cursor:pointer; font-size:12px; margin-top:10px; }
#helpClose:hover { background:#0052a3; }
</style>
</head>
<body>
<div id="toolbar">
    <button onclick="saveSession()">üíæ Save Session</button>
    <button onclick="document.getElementById('fileInput').click()">üìÇ Load Session</button>
    <input type="file" id="fileInput" accept=".txt,.soql" onchange="loadSession(event)">
    
    <select id="envSelector" onchange="changeEnvironment()" style="margin-left:20px; padding:6px 12px; border-radius:4px; border:1px solid #ccc;">
        <option value="">Select Environment</option>
    </select>
    
    <label id="autocompleteToggle">
        <input type="checkbox" id="autocompleteEnabled" checked onchange="toggleAutocomplete()">
        Autocomplete
    </label>
    
    <div style="margin-left:auto; font-size:12px; color:#666; display:flex; flex-direction:column; align-items:flex-end; gap:2px;">
        <span>Press Ctrl+E on a query block to execute SOQL or REST</span>
        <span onclick="toggleHelp()" style="cursor:pointer; text-decoration:underline; font-size:11px;" title="Keyboard Shortcuts">Help</span>
    </div>
</div>

<div id="helpModal" onclick="if(event.target===this) toggleHelp()">
    <div id="helpContent">
        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
        <table>
            <tr><td>Ctrl+E</td><td>Execute query block</td></tr>
            <tr><td>Ctrl+F</td><td>Find in editor/results</td></tr>
            <tr><td>Ctrl+A</td><td>Select all (in results)</td></tr>
            <tr><td>Tab / Enter</td><td>Select autocomplete item</td></tr>
            <tr><td>, (comma)</td><td>Select item + add comma</td></tr>
            <tr><td>. (period)</td><td>Select relation + traverse</td></tr>
            <tr><td>‚Üë ‚Üì</td><td>Navigate autocomplete</td></tr>
            <tr><td>PgUp / PgDn</td><td>Jump 5 items</td></tr>
            <tr><td>Escape</td><td>Close popup/search</td></tr>
        </table>
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid #eee; font-size:12px; color:#666; text-align:center;">
            Learn more at <a href="#" onclick="event.preventDefault(); window.api.openExternal('https://getplayforce.com/')" style="color:#0066cc;">getplayforce.com</a>
        </div>
        <button id="helpClose" onclick="toggleHelp()">Close</button>
    </div>
</div>

<div id="top" style="background:#f0f0f0; position:relative;">
<textarea id="editor" placeholder="Type SOQL queries or REST paths here..." spellcheck="false"></textarea>
<div id="autocomplete"></div>
<div id="editorSearch" class="search-box">
    <input type="text" placeholder="Search..." id="editorSearchInput">
    <span id="editorMatchCount" style="font-size:11px; color:#666; margin-right:4px;"></span>
    <button onclick="findNext('editor')" title="Find Next (Enter)">‚Üì</button>
    <button onclick="findPrev('editor')" title="Find Previous (Shift+Enter)">‚Üë</button>
    <button onclick="closeSearch('editor')" title="Close (Escape)">‚úï</button>
</div>
</div>
<div id="splitter"></div>
<div id="bottom" style="background:#fff; display:flex; flex-direction:column; position:relative;">
    <div id="results-header">
        <span id="resultsCount" style="font-size:14px; font-family:monospace; color:#666; margin-right:auto;"></span>
        <button id="stopQueryBtn" onclick="stopQuery()">‚èπ Stop Query</button>
        <button id="exportJsonBtn" onclick="exportToJSON()" tabindex="-1" style="display:none;">üìÑ Export JSON</button>
        <button id="exportCsvBtn" onclick="exportToCSV()" tabindex="-1" style="display:none;">üìä Export CSV</button>
        <button id="copyResultsBtn" tabindex="-1">üìã Copy Results</button>
    </div>
    <div id="log" tabindex="0">üëâ Select an environment first, then press Ctrl+E on a block above to execute.</div>
    <div id="logSearch" class="search-box">
        <input type="text" placeholder="Search..." id="logSearchInput">
        <span id="logMatchCount" style="font-size:11px; color:#666; margin-right:4px;"></span>
        <button onclick="findNext('log')" title="Find Next (Enter)">‚Üì</button>
        <button onclick="findPrev('log')" title="Find Previous (Shift+Enter)">‚Üë</button>
        <button onclick="closeSearch('log')" title="Close (Escape)">‚úï</button>
    </div>
</div>

<script>
// Global variable to store the actual OAuth redirect URI
let currentRedirectUri = null;

// Autocomplete state
let sobjectsCache = null; // Cached list of SObjects
let objectFieldsCache = {}; // Cached field metadata per object: { objectName: fieldsArray }
let autocompleteVisible = false;
let autocompleteSelectedIndex = -1;
let autocompleteItems = [];
let autocompleteEnabled = localStorage.getItem('autocompleteEnabled') !== 'false'; // Default true

// Store current result data for export
let currentResultData = null;

// Toggle autocomplete feature
function toggleAutocomplete() {
    autocompleteEnabled = document.getElementById('autocompleteEnabled').checked;
    localStorage.setItem('autocompleteEnabled', autocompleteEnabled);
    if (!autocompleteEnabled) {
        hideAutocomplete();
    }
}

// Toggle help modal
function toggleHelp() {
    const modal = document.getElementById('helpModal');
    if (modal.style.display === 'flex') {
        modal.style.display = 'none';
    } else {
        modal.style.display = 'flex';
    }
}

// Export results to JSON
function exportToJSON() {
    if (!currentResultData) return;
    
    const jsonStr = JSON.stringify(currentResultData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const now = new Date();
    const timestamp = now.getFullYear() + '-' + 
        String(now.getMonth() + 1).padStart(2, '0') + '-' + 
        String(now.getDate()).padStart(2, '0') + 'T' + 
        String(now.getHours()).padStart(2, '0') + '-' + 
        String(now.getMinutes()).padStart(2, '0') + '-' + 
        String(now.getSeconds()).padStart(2, '0');
    a.download = `export_${timestamp}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

// Export results to CSV
function exportToCSV() {
    if (!currentResultData) return;
    
    const records = currentResultData.records || currentResultData;
    if (!records || records.length === 0) return;
    
    // Get headers (excluding attributes)
    const headers = Object.keys(records[0]).filter(h => h !== 'attributes');
    
    // Build CSV
    let csv = headers.join(',') + '\n';
    
    records.forEach(record => {
        const row = headers.map(header => {
            let value = record[header];
            
            // Handle null/undefined
            if (value === null || value === undefined) return '';
            
            // Handle nested objects (like relationships)
            if (typeof value === 'object') {
                value = JSON.stringify(value);
            }
            
            // Convert to string and escape
            value = String(value);
            
            // Escape quotes and wrap in quotes if contains comma, quote, or newline
            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                value = '"' + value.replace(/"/g, '""') + '"';
            }
            
            return value;
        });
        csv += row.join(',') + '\n';
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const now = new Date();
    const timestamp = now.getFullYear() + '-' + 
        String(now.getMonth() + 1).padStart(2, '0') + '-' + 
        String(now.getDate()).padStart(2, '0') + 'T' + 
        String(now.getHours()).padStart(2, '0') + '-' + 
        String(now.getMinutes()).padStart(2, '0') + '-' + 
        String(now.getSeconds()).padStart(2, '0');
    a.download = `export_${timestamp}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

// Highlight SOQL keywords
function highlightSOQL(query) {
    const keywords = /\b(SELECT|FROM|WHERE|LIMIT|ORDER BY|GROUP BY|AND|OR|NOT|NULL)\b/gi;
    return query.replace(keywords, '<span class="keyword">$1</span>');
}

// Environment functions
async function loadEnvironments() {
    if (!window.api?.listConfigs) return;
    const configs = await window.api.listConfigs();
    const selector = document.getElementById('envSelector');
    while (selector.children.length > 1) selector.removeChild(selector.lastChild);
    if (!configs.length) {
        const opt = document.createElement('option'); opt.textContent='No configs found'; opt.disabled=true; selector.appendChild(opt);
    } else {
        configs.forEach(c=>{ const opt=document.createElement('option'); opt.value=c; opt.textContent=c; selector.appendChild(opt); });
    }
}

async function changeEnvironment() {
    const sel=document.getElementById('envSelector'); if(!sel.value) return;
    try {
        const success = await window.api.setConfigFile(sel.value);
        if(success){
            // Clear autocomplete caches when switching environments
            sobjectsCache = null;
            objectFieldsCache = {};
            
            log.innerHTML='';
            const msg = document.createElement('div');
            msg.className='log-line';
            msg.style.background="#d1ecf1"; msg.style.color="#0c5460"; msg.style.padding="5px";
            msg.textContent=`üîÑ Switched to ${sel.value} environment`;
            log.appendChild(msg);
            document.title = `Playforce Query - ${sel.value}`;
            
            // Auto-authenticate based on grant type
            await autoAuthenticate();
            
            // Eagerly fetch object list for autocomplete
            fetchSObjects().catch(err => console.log('Could not pre-fetch objects:', err.message));
        } else alert('Failed to switch environment');
    } catch(err){ alert(err.message); }
}

// Auto-authenticate based on grant type
async function autoAuthenticate() {
    const log = document.getElementById('log');
    
    try {
        // First check if we already have a valid token for this environment
        const hasToken = await window.api.hasValidToken();
        
        if (hasToken) {
            // Already authenticated - just show ready message
            const readyMsg = document.createElement('div');
            readyMsg.className = 'log-line';
            readyMsg.style.background = "#d4edda";
            readyMsg.style.color = "#155724";
            readyMsg.style.padding = "5px";
            readyMsg.textContent = `‚úÖ Using cached token - Ready to execute queries`;
            log.appendChild(readyMsg);
            return;
        }
        
        // No cached token, try authentication (will attempt client_credentials if no username/password)
        const result = await window.api.tryAuthenticate();
        
        if (result.success) {
            // Authentication successful
            const readyMsg = document.createElement('div');
            readyMsg.className = 'log-line';
            readyMsg.style.background = "#d4edda";
            readyMsg.style.color = "#155724";
            readyMsg.style.padding = "5px";
            const method = result.method === 'client_credentials' ? 'client credentials' : 'password';
            readyMsg.textContent = `‚úÖ Authenticated with ${method} - Ready to execute queries`;
            log.appendChild(readyMsg);
        } else if (result.needsOAuth) {
            // Client credentials failed, need OAuth
            const infoMsg = document.createElement('div');
            infoMsg.className = 'log-line';
            infoMsg.style.background = "#d1ecf1";
            infoMsg.style.color = "#0c5460";
            infoMsg.style.padding = "5px";
            infoMsg.textContent = 'üîê Client credentials not available, starting OAuth flow...';
            log.appendChild(infoMsg);
            
            // Start OAuth flow
            const oauthResult = await window.api.startOAuthFlow();
            
            if (!oauthResult.success) {
                throw new Error(oauthResult.error);
            }
            
            // Store the actual redirect URI that was used
            currentRedirectUri = oauthResult.redirectUri;
            
            // Warn if using non-default port
            if (!currentRedirectUri.includes(':8888/')) {
                const portWarning = document.createElement('div');
                portWarning.className = 'log-line';
                portWarning.style.background = "#fff3cd";
                portWarning.style.color = "#856404";
                portWarning.style.padding = "5px";
                portWarning.style.fontWeight = "bold";
                portWarning.textContent = `‚ö†Ô∏è Using ${currentRedirectUri} - Make sure ALL ports (8888-8892) are configured in your Salesforce External Client App!`;
                log.appendChild(portWarning);
            }
            
            const waitingMsg = document.createElement('div');
            waitingMsg.className = 'log-line';
            waitingMsg.style.background = "#fff3cd";
            waitingMsg.style.color = "#856404";
            waitingMsg.style.padding = "5px";
            waitingMsg.textContent = '‚è≥ Please authenticate in your browser...';
            log.appendChild(waitingMsg);
        } else {
            // Some other error
            throw new Error(result.error || 'Authentication failed');
        }
    } catch (error) {
        const errorMsg = document.createElement('div');
        errorMsg.className = 'log-line';
        errorMsg.style.background = "#f8d7da";
        errorMsg.style.color = "#721c24";
        errorMsg.style.padding = "5px";
        errorMsg.textContent = `‚ùå Authentication Error: ${error.message}`;
        log.appendChild(errorMsg);
    }
}

// Setup OAuth callback handlers
if (window.api?.onOAuthCallback) {
    window.api.onOAuthCallback(async (authCode) => {
        const log = document.getElementById('log');
        
        try {
            const exchangeMsg = document.createElement('div');
            exchangeMsg.className = 'log-line';
            exchangeMsg.style.background = "#d1ecf1";
            exchangeMsg.style.color = "#0c5460";
            exchangeMsg.style.padding = "5px";
            exchangeMsg.textContent = 'üîÑ Exchanging authorization code for access token...';
            log.appendChild(exchangeMsg);
            
            if (!currentRedirectUri) {
                throw new Error('Redirect URI not found. Please restart the OAuth flow.');
            }
            
            const result = await window.api.exchangeAuthCode(authCode, currentRedirectUri);
            
            if (result.success) {
                const successMsg = document.createElement('div');
                successMsg.className = 'log-line';
                successMsg.style.background = "#d4edda";
                successMsg.style.color = "#155724";
                successMsg.style.padding = "5px";
                successMsg.textContent = '‚úÖ OAuth authentication successful! You can now execute queries.';
                log.appendChild(successMsg);
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            const errorMsg = document.createElement('div');
            errorMsg.className = 'log-line';
            errorMsg.style.background = "#f8d7da";
            errorMsg.style.color = "#721c24";
            errorMsg.style.padding = "5px";
            errorMsg.textContent = `‚ùå Token Exchange Error: ${error.message}`;
            log.appendChild(errorMsg);
        }
    });
}

if (window.api?.onOAuthError) {
    window.api.onOAuthError((error) => {
        const log = document.getElementById('log');
        const errorMsg = document.createElement('div');
        errorMsg.className = 'log-line';
        errorMsg.style.background = "#f8d7da";
        errorMsg.style.color = "#721c24";
        errorMsg.style.padding = "5px";
        errorMsg.textContent = `‚ùå OAuth Error: ${error.error} - ${error.error_description || 'Unknown error'}`;
        log.appendChild(errorMsg);
    });
}

// Session save/load
function saveSession() {
    const now = new Date();
    const timestamp = now.getFullYear() + '-' + 
        String(now.getMonth() + 1).padStart(2, '0') + '-' + 
        String(now.getDate()).padStart(2, '0') + 'T' + 
        String(now.getHours()).padStart(2, '0') + '-' + 
        String(now.getMinutes()).padStart(2, '0') + '-' + 
        String(now.getSeconds()).padStart(2, '0');
    const blob=new Blob([editor.value],{type:'text/plain'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`soql-session-${timestamp}.txt`; a.click(); URL.revokeObjectURL(a.href);
}
function loadSession(e){
    const file=e.target.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=function(ev){
        editor.value=ev.target.result;
        log.innerHTML=''; const msg=document.createElement('div');
        msg.className='log-line'; msg.style.background="#d4edda"; msg.style.color="#155724"; msg.style.padding="5px";
        msg.textContent=`‚úÖ Session loaded from ${file.name}`;
        log.appendChild(msg);
    }; reader.readAsText(file); e.target.value='';
}

// Splitter (fixed version using flex-basis)
const splitter = document.getElementById("splitter"),
      topDiv = document.getElementById("top"),
      bottomDiv = document.getElementById("bottom");

let isDragging = false;

splitter.addEventListener("mousedown", () => {
    isDragging = true;
    document.body.style.cursor = "row-resize";
    topDiv.style.flex = "none";
    bottomDiv.style.flex = "none";
});

document.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const offsetY = e.clientY;
    const toolbarHeight = document.getElementById("toolbar").offsetHeight;
    const totalHeight = window.innerHeight - toolbarHeight - splitter.offsetHeight;

    const topHeight = Math.max(50, offsetY - toolbarHeight);
    const bottomHeight = Math.max(50, totalHeight - (offsetY - toolbarHeight));

    topDiv.style.height = `${topHeight}px`;
    bottomDiv.style.height = `${bottomHeight}px`;
});

document.addEventListener("mouseup", () => {
    if (!isDragging) return;
    isDragging = false;
    document.body.style.cursor = "default";
});

const editor = document.getElementById("editor");
const log = document.getElementById("log");

// Format Salesforce error messages for better readability
function formatErrorMessage(errorMessage) {
    // Try to extract REST API error details
    const restErrorMatch = errorMessage.match(/REST API error: \[(.*?)\](?:\s*URL:\s*(.*))?$/s);
    if (restErrorMatch) {
        try {
            const errors = JSON.parse('[' + restErrorMatch[1] + ']');
            if (errors && errors.length > 0) {
                const error = errors[0];
                let formatted = '‚ùå <strong>REST API Error</strong>';
                
                // Show error code and message
                if (error.errorCode) {
                    formatted += '<br><strong>' + error.errorCode + ':</strong> ';
                } else {
                    formatted += '<br>';
                }
                
                if (error.message) {
                    formatted += error.message;
                }
                
                // Show URL if present
                if (restErrorMatch[2]) {
                    formatted += '<br><span style="color:#666;font-size:12px">URL: ' + restErrorMatch[2].trim() + '</span>';
                }
                
                return formatted;
            }
        } catch (e) {
            // If parsing fails, fall through to default handling
        }
    }
    
    // Try to extract Salesforce SOQL error details
    const soqlErrorMatch = errorMessage.match(/Salesforce SOQL error: \[(.*)\]$/s);
    if (soqlErrorMatch) {
        try {
            const errors = JSON.parse('[' + soqlErrorMatch[1] + ']');
            if (errors && errors.length > 0) {
                const error = errors[0];
                let formatted = '‚ùå <strong>SOQL Error</strong>';
                
                // Extract the error message, removing the query part if present
                if (error.message) {
                    const messageParts = error.message.split('ERROR at');
                    if (messageParts.length > 1) {
                        // Show the error location
                        const locationPart = 'ERROR at' + messageParts[1].split('\n')[0];
                        formatted += '<br><span style="color:#666">' + locationPart + '</span>';
                        
                        // Show the actual error message (everything after the location line)
                        const errorLines = messageParts[1].split('\n').slice(1).join('\n').trim();
                        if (errorLines) {
                            formatted += '<br>' + errorLines.replace(/\n/g, '<br>');
                        }
                    } else {
                        // No location info, just show the message
                        formatted += '<br>' + error.message.trim().replace(/\n/g, '<br>');
                    }
                }
                
                // Show error code if present
                if (error.errorCode) {
                    formatted += '<br><span style="color:#999;font-size:12px">Code: ' + error.errorCode + '</span>';
                }
                
                return formatted;
            }
        } catch (e) {
            // If parsing fails, fall through to default handling
        }
    }
    
    // Try to extract other IPC errors
    const ipcMatch = errorMessage.match(/Error invoking remote method '([^']+)':\s*Error:\s*(.*)/s);
    if (ipcMatch) {
        return formatErrorMessage(ipcMatch[2]); // Recursively format the inner error
    }
    
    // Default: just return the message with line breaks
    return '‚ùå ' + errorMessage.replace(/\n/g, '<br>');
}

// Copy button
document.getElementById('copyResultsBtn').addEventListener('click',()=>{ if(!log.innerText) return; navigator.clipboard.writeText(log.innerText).catch(err=>alert('‚ùå Failed to copy results')); });

// Ctrl+A in log - select all results content
log.addEventListener('keydown',e=>{ 
    if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='a'){ 
        e.preventDefault(); 
        const r=document.createRange(); 
        r.selectNodeContents(log); 
        const s=window.getSelection(); 
        s.removeAllRanges(); 
        s.addRange(r); 
    } 
});

// Auto-focus log when clicked
log.addEventListener('click', () => log.focus());

// Global Escape handler to close search boxes or stop query
document.addEventListener('keydown', e => {
    if(e.key === 'Escape') {
        const editorSearch = document.getElementById('editorSearch');
        const logSearch = document.getElementById('logSearch');
        const helpModal = document.getElementById('helpModal');
        
        // Priority 1: Close help modal if open
        if(helpModal.style.display === 'flex') {
            toggleHelp();
        // Priority 2: Close search boxes if open
        } else if(editorSearch.style.display === 'block') {
            closeSearch('editor');
        } else if(logSearch.style.display === 'block') {
            closeSearch('log');
        } else if(currentQueryId) {
            // Priority 3: Stop running query if no popups are open
            stopQuery();
        }
    }
});

// Search functionality
let currentMatches = {};
let currentMatchIndex = {};

function openSearch(pane) {
    const searchBox = document.getElementById(pane === 'editor' ? 'editorSearch' : 'logSearch');
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    searchBox.style.display = 'block';
    input.focus();
}

function closeSearch(pane) {
    const searchBox = document.getElementById(pane === 'editor' ? 'editorSearch' : 'logSearch');
    searchBox.style.display = 'none';
    clearHighlights(pane);
}

function clearHighlights(pane) {
    if(pane === 'editor') {
        // For textarea, we can't highlight directly, so we'll just clear selection
        editor.setSelectionRange(0, 0);
        document.getElementById('editorMatchCount').textContent = '';
    } else {
        // For log, remove highlight spans
        const highlights = log.querySelectorAll('.search-highlight, .search-current');
        highlights.forEach(span => {
            const parent = span.parentNode;
            parent.replaceChild(document.createTextNode(span.textContent), span);
            parent.normalize();
        });
        document.getElementById('logMatchCount').textContent = '';
    }
    currentMatches[pane] = [];
    currentMatchIndex[pane] = -1;
}

function findInEditor(searchText, direction = 1) {
    if(!searchText) return;
    
    const text = editor.value.toLowerCase();
    const searchLower = searchText.toLowerCase();
    const matches = [];
    let pos = 0;
    
    // Find all matches
    while((pos = text.indexOf(searchLower, pos)) !== -1) {
        matches.push(pos);
        pos++;
    }
    
    if(matches.length === 0) return;
    
    // Initialize or update current match index
    if(!currentMatches['editor'] || currentMatches['editor'].searchText !== searchText) {
        currentMatches['editor'] = { matches: matches, searchText: searchText };
        currentMatchIndex['editor'] = 0;
    } else {
        const currentPos = editor.selectionStart;
        let nearestIndex = 0;
        
        // Find current position in matches
        for(let i = 0; i < matches.length; i++) {
            if(matches[i] >= currentPos) {
                nearestIndex = i;
                break;
            }
        }
        
        if(direction > 0) {
            currentMatchIndex['editor'] = (nearestIndex < matches.length - 1) ? nearestIndex + 1 : 0;
        } else {
            currentMatchIndex['editor'] = (nearestIndex > 0) ? nearestIndex - 1 : matches.length - 1;
        }
    }
    
    const matchPos = matches[currentMatchIndex['editor']];
    editor.setSelectionRange(matchPos, matchPos + searchText.length);
    editor.focus();
    
    // Update match counter
    const counter = document.getElementById('editorMatchCount');
    counter.textContent = `${currentMatchIndex['editor'] + 1} of ${matches.length}`;
    
    // Scroll to the selection in textarea - use a more reliable method
    setTimeout(() => {
        const textBeforeMatch = editor.value.substring(0, matchPos);
        const lines = textBeforeMatch.split('\n');
        const lineNumber = lines.length - 1;
        const computedStyle = getComputedStyle(editor);
        const lineHeight = parseFloat(computedStyle.lineHeight) || parseFloat(computedStyle.fontSize) * 1.2 || 16;
        const targetScrollTop = lineNumber * lineHeight - (editor.clientHeight / 2);
        editor.scrollTop = Math.max(0, targetScrollTop);
    }, 10);
}

function findInLog(searchText, direction = 1) {
    if(!searchText) return;
    
    // Only rebuild matches if search text changed
    if(!currentMatches['log'] || currentMatches['log'].searchText !== searchText) {
        clearHighlights('log');
        const text = log.textContent;
        const regex = new RegExp(escapeRegex(searchText), 'gi');
        let match;
        const matches = [];
        
        while((match = regex.exec(text)) !== null) {
            matches.push({start: match.index, end: match.index + match[0].length});
        }
        
        if(matches.length === 0) return;
        
        currentMatches['log'] = { matches: matches, searchText: searchText };
        currentMatchIndex['log'] = 0;
    } else {
        // Navigate through existing matches
        const matches = currentMatches['log'].matches;
        currentMatchIndex['log'] += direction;
        if(currentMatchIndex['log'] >= matches.length) currentMatchIndex['log'] = 0;
        if(currentMatchIndex['log'] < 0) currentMatchIndex['log'] = matches.length - 1;
    }
    
    highlightLogMatches(searchText, currentMatchIndex['log']);
    
    // Update match counter
    const counter = document.getElementById('logMatchCount');
    const matches = currentMatches['log'].matches;
    counter.textContent = `${currentMatchIndex['log'] + 1} of ${matches.length}`;
}

function highlightLogMatches(searchText, currentIndex) {
    // Check if highlights already exist
    const existingHighlights = log.querySelectorAll('.search-highlight, .search-current');
    
    if(existingHighlights.length === 0) {
        // First time highlighting - walk through text nodes only
        const regex = new RegExp(escapeRegex(searchText), 'gi');
        let matchIndex = 0;
        
        function highlightTextNode(node) {
            if(node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent;
                const matches = [];
                let match;
                regex.lastIndex = 0;
                while((match = regex.exec(text)) !== null) {
                    matches.push({ start: match.index, end: match.index + match[0].length, text: match[0] });
                }
                
                if(matches.length > 0) {
                    const fragment = document.createDocumentFragment();
                    let lastEnd = 0;
                    
                    matches.forEach(m => {
                        if(m.start > lastEnd) {
                            fragment.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
                        }
                        
                        const span = document.createElement('span');
                        span.className = matchIndex === currentIndex ? 'search-current' : 'search-highlight';
                        if(matchIndex === currentIndex) {
                            span.id = 'current-search-match';
                        }
                        span.textContent = m.text;
                        fragment.appendChild(span);
                        
                        lastEnd = m.end;
                        matchIndex++;
                    });
                    
                    if(lastEnd < text.length) {
                        fragment.appendChild(document.createTextNode(text.substring(lastEnd)));
                    }
                    
                    node.parentNode.replaceChild(fragment, node);
                }
            } else if(node.nodeType === Node.ELEMENT_NODE) {
                // Skip search highlight spans
                if(!node.classList.contains('search-highlight') && !node.classList.contains('search-current')) {
                    Array.from(node.childNodes).forEach(child => highlightTextNode(child));
                }
            }
        }
        
        highlightTextNode(log);
    } else {
        // Update existing highlights - just change classes
        existingHighlights.forEach((span, index) => {
            span.className = index === currentIndex ? 'search-current' : 'search-highlight';
            if(index === currentIndex) {
                span.id = 'current-search-match';
            } else {
                span.removeAttribute('id');
            }
        });
    }
    
    // Scroll to current match
    setTimeout(() => {
        const currentMatch = document.getElementById('current-search-match');
        if(currentMatch) {
            currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        }
    }, 10);
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findNext(pane) {
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    const searchText = input.value.trim();
    if(!searchText) return;
    
    if(pane === 'editor') {
        findInEditor(searchText, 1);
    } else {
        findInLog(searchText, 1);
    }
}

function findPrev(pane) {
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    const searchText = input.value.trim();
    if(!searchText) return;
    
    if(pane === 'editor') {
        findInEditor(searchText, -1);
    } else {
        findInLog(searchText, -1);
    }
}

// Ctrl+F handlers for both panes
editor.addEventListener('keydown', e => {
    // Allow standard undo/redo
    if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'z' || e.key.toLowerCase() === 'y')) {
        return; // Let browser handle undo/redo
    }
    
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearch('editor');
    }
});

log.addEventListener('keydown', e => {
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearch('log');
    }
});

// Search input handlers
document.getElementById('editorSearchInput').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
        e.preventDefault();
        if(e.shiftKey) {
            findPrev('editor');
        } else {
            findNext('editor');
        }
    } else if(e.key === 'Escape') {
        closeSearch('editor');
    }
});

document.getElementById('editorSearchInput').addEventListener('input', e => {
    const searchText = e.target.value.trim();
    if(searchText) {
        currentMatches['editor'] = null; // Reset to trigger new search
        findInEditor(searchText, 1);
    } else {
        clearHighlights('editor');
    }
});

document.getElementById('logSearchInput').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
        e.preventDefault();
        if(e.shiftKey) {
            findPrev('log');
        } else {
            findNext('log');
        }
    } else if(e.key === 'Escape') {
        closeSearch('log');
    }
});

document.getElementById('logSearchInput').addEventListener('input', e => {
    const searchText = e.target.value.trim();
    if(searchText) {
        currentMatches['log'] = null; // Reset to trigger new search
        findInLog(searchText, 1);
    } else {
        clearHighlights('log');
    }
});

// Global variables to track current query and table for progressive rendering
let currentQueryId = null;
let currentTable = null;
let currentTbody = null;
let queryStartTime = null;
let queryTimerInterval = null;

// Stop query function
async function stopQuery() {
    if (!currentQueryId) return;
    
    try {
        console.log('Stopping query:', currentQueryId);
        await window.api.abortQuery(currentQueryId);
        
        // Clear live timer
        if (queryTimerInterval) {
            clearInterval(queryTimerInterval);
            queryTimerInterval = null;
        }
        
        currentQueryId = null;
    } catch (error) {
        console.error('Error stopping query:', error);
    }
}

// Listen for pagination progress events
if(window.api?.onSOQLProgress) {
    window.api.onSOQLProgress((progress) => {
        console.log('Progress update:', progress);
        
        // Clear the live timer once pagination starts
        if (queryTimerInterval) {
            clearInterval(queryTimerInterval);
            queryTimerInterval = null;
        }
        
        if (!progress.records || progress.records.length === 0) return;
        
        const headers = Object.keys(progress.records[0]).filter(h => h !== "attributes");
        
        // If table doesn't exist yet, create it with first batch
        if (!currentTable || !currentTbody) {
            const headerLabels = headers.map(h => (/^expr\d+$/i.test(h) && headers.length === 1) ? "COUNT" : h);
            const tableEl = document.createElement("table");
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");
            
            // Add row number column header
            const rowNumTh = document.createElement("th");
            rowNumTh.textContent = "#";
            rowNumTh.style.width = "40px";
            rowNumTh.style.textAlign = "right";
            headerRow.appendChild(rowNumTh);
            
            headerLabels.forEach(lbl => { const th = document.createElement("th"); th.textContent = lbl; headerRow.appendChild(th); });
            thead.appendChild(headerRow); tableEl.appendChild(thead);
            
            const tbody = document.createElement("tbody");
            tableEl.appendChild(tbody);
            log.appendChild(tableEl);
            
            currentTable = tableEl;
            currentTbody = tbody;
        }
        
        // Add new rows
        const existingRowCount = currentTbody.children.length;
        const newRecords = progress.records.slice(existingRowCount);
        
        newRecords.forEach((rec, idx) => {
            const tr = document.createElement("tr");
            
            // Add row number cell
            const rowNumTd = document.createElement("td");
            rowNumTd.textContent = existingRowCount + idx + 1;
            rowNumTd.style.textAlign = "right";
            rowNumTd.style.color = "#666";
            tr.appendChild(rowNumTd);
            
            headers.forEach(h => {
                const td = document.createElement("td");
                let val = rec[h];
                if (val === null || val === undefined) td.textContent = "";
                else if (typeof val === "object") {
                    if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                    else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
                } else td.textContent = String(val);
                tr.appendChild(td);
            });
            currentTbody.appendChild(tr);
        });
        
        // Update counter
        if (progress.done) {
            const elapsedMs = Date.now() - queryStartTime;
            const elapsedSec = (elapsedMs / 1000).toFixed(2);
            const totalSize = progress.totalSize || progress.fetchedCount;
            if (totalSize > progress.fetchedCount) {
                document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} of ${totalSize} (${elapsedSec}s)`;
            } else {
                document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} (${elapsedSec}s)`;
            }
        } else {
            const elapsedMs = Date.now() - queryStartTime;
            const elapsedSec = (elapsedMs / 1000).toFixed(1);
            document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} of ${progress.totalSize} (fetching page ${progress.pageNumber}... ${elapsedSec}s)`;
        }
    });
}

// Ctrl+E handler supporting multi-line SOQL separated by blank lines
editor.addEventListener("keydown",async e=>{
    if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='e'){
        e.preventDefault(); if(!window.api){ alert("Error: API not loaded."); return; }

        // Close autocomplete if open
        hideAutocomplete();

        // Check if environment is selected
        const envSelector = document.getElementById('envSelector');
        if (!envSelector.value) {
            log.innerHTML = '';
            currentResultData = null;
            document.getElementById('exportJsonBtn').style.display = 'none';
            document.getElementById('exportCsvBtn').style.display = 'none';
            showEnvironmentReminder();
            return;
        }

        const text = editor.value;
        const cursorPos = editor.selectionStart;

        // Find the block containing the cursor
        const lines = text.split('\n');
        let charPos = 0;
        let blockStart = -1;
        let blockEnd = -1;
        let blockLines = [];
        let inBlock = false;
        
        for(let i = 0; i < lines.length; i++){
            const line = lines[i];
            const lineStart = charPos;
            const lineEnd = charPos + line.length;
            
            if(line.trim() === ''){
                if(inBlock){
                    blockEnd = charPos - 1; // End before the empty line
                    if(cursorPos >= blockStart && cursorPos <= blockEnd) break;
                    blockStart = -1;
                    blockLines = [];
                    inBlock = false;
                }
            } else {
                if(!inBlock){
                    blockStart = lineStart;
                    inBlock = true;
                }
                blockLines.push(line);
                blockEnd = lineEnd;
            }
            charPos += line.length + 1; // +1 for newline
        }
        
        // Check if cursor is in the found block
        if(blockStart === -1 || cursorPos < blockStart || cursorPos > blockEnd){
            return;
        }
        
        const targetBlock = blockLines.map(l => l.trim()).join('\n').trim();
        if(!targetBlock) return;

        // Highlight the block being executed
        editor.setSelectionRange(blockStart, blockEnd);
        editor.focus();

        log.innerHTML='';
        currentTable = null;
        currentTbody = null;
        currentResultData = null;
        document.getElementById('exportJsonBtn').style.display = 'none';
        document.getElementById('exportCsvBtn').style.display = 'none';
        currentQueryId = 'query_' + Date.now();
        queryStartTime = Date.now();
        document.getElementById('resultsCount').textContent = '';
        document.getElementById('stopQueryBtn').style.display = 'inline-block';
        
        // Start live timer to show execution progress
        queryTimerInterval = setInterval(() => {
            const elapsedMs = Date.now() - queryStartTime;
            const elapsedSec = (elapsedMs / 1000).toFixed(1);
            document.getElementById('resultsCount').textContent = `Executing... (${elapsedSec}s)`;
        }, 100);
        
        document.body.style.cursor = 'wait';
        editor.style.cursor = 'wait';
        try{
            const soqlKeywords=/^(SELECT|UPDATE|DELETE|INSERT|UPSERT|MERGE)\b/i;
            if(soqlKeywords.test(targetBlock)){
                // Remove // and -- comments from SOQL
                const cleanedBlock = targetBlock.split('\n').map(l=>l.replace(/(\/\/|--).*/,'').trim()).join('\n').trim();
                const result = await window.api.executeSOQL(cleanedBlock, currentQueryId);
                
                // Check if query was aborted
                if (result && result.aborted) {
                    const errEl=document.createElement("div"); errEl.className="log-line";
                    errEl.style.background = '#fff3cd';
                    errEl.style.color = '#856404';
                    errEl.innerHTML = '‚èπ Query was stopped';
                    log.appendChild(errEl);
                    
                    // If we have partial results from pagination, keep them exportable
                    if (currentTable && currentTbody && currentTbody.children.length > 0) {
                        // Extract partial data from the rendered table for export
                        const rows = Array.from(currentTbody.children);
                        const headerCells = Array.from(currentTable.querySelector('thead tr').children);
                        const headers = headerCells.slice(1).map(th => th.textContent); // Skip row number column
                        
                        const partialRecords = rows.map(row => {
                            const record = {};
                            const cells = Array.from(row.children).slice(1); // Skip row number column
                            headers.forEach((header, idx) => {
                                record[header] = cells[idx].textContent;
                            });
                            return record;
                        });
                        
                        currentResultData = { records: partialRecords, totalSize: partialRecords.length };
                        document.getElementById('exportJsonBtn').style.display = 'inline-block';
                        document.getElementById('exportCsvBtn').style.display = 'inline-block';
                        
                        const elapsedMs = queryStartTime ? Date.now() - queryStartTime : 0;
                        const elapsedSec = (elapsedMs / 1000).toFixed(2);
                        document.getElementById('resultsCount').textContent = `Results: ${partialRecords.length} (partial, ${elapsedSec}s)`;
                    }
                } else {
                    renderResult(result);
                }
            } else {
                // Treat each non-empty line as a REST path
                const lines = targetBlock.split("\n").map(l=>l.trim()).filter(l=>l);
                for(const path of lines){
                    try{
                        // Remove // and -- comments from REST paths
                        const cleanedPath = path.replace(/(\/\/|--).*/,'').trim();
                        if(!cleanedPath) continue;
                        const res = await window.api.executeREST(cleanedPath);
                        renderResult(res);
                    } catch(err){
                        const errEl=document.createElement("div"); errEl.className="log-line";
                        errEl.innerHTML=formatErrorMessage(err.message);
                        log.appendChild(errEl);
                    }
                }
            }
        } catch(err){
            const errEl=document.createElement("div"); errEl.className="log-line";
            errEl.innerHTML=formatErrorMessage(err.message);
            log.appendChild(errEl);
        }
        
        // Clear live timer
        if (queryTimerInterval) {
            clearInterval(queryTimerInterval);
            queryTimerInterval = null;
        }
        
        document.getElementById('stopQueryBtn').style.display = 'none';
        currentQueryId = null;
        document.body.style.cursor = 'default';
        editor.style.cursor = 'text';
        log.scrollTop = 0;
    }
});

// Render results helper
function renderResult(result) {
    const elapsedMs = queryStartTime ? Date.now() - queryStartTime : 0;
    const elapsedSec = (elapsedMs / 1000).toFixed(2);
    
    // Store result data for export
    currentResultData = result;
    
    // Show export buttons if we have exportable data
    // JSON export: always available if we have any result
    const hasAnyData = (result && typeof result === 'object');
    document.getElementById('exportJsonBtn').style.display = hasAnyData ? 'inline-block' : 'none';
    
    // CSV export: only available for records (SOQL results)
    const hasRecords = (result && (result.records || Array.isArray(result)));
    document.getElementById('exportCsvBtn').style.display = hasRecords ? 'inline-block' : 'none';
    
    // If table was already rendered progressively, just update the final counter
    if (currentTable && currentTbody) {
        const records = result.records || result;
        const totalSize = result.totalSize || records.length;
        if (totalSize > records.length) {
            document.getElementById('resultsCount').textContent = `Results: ${records.length} of ${totalSize} (${elapsedSec}s)`;
        } else {
            document.getElementById('resultsCount').textContent = `Results: ${records.length} (${elapsedSec}s)`;
        }
        return;
    }
    
    if (result && result.totalSize !== undefined && (!result.records || result.records.length === 0)) {
        const tableEl = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const th = document.createElement("th"); th.textContent = "COUNT";
        headerRow.appendChild(th); thead.appendChild(headerRow); tableEl.appendChild(thead);
        const tbody = document.createElement("tbody");
        const tr = document.createElement("tr"); const td = document.createElement("td");
        td.textContent = result.totalSize; tr.appendChild(td); tbody.appendChild(tr); tableEl.appendChild(tbody);
        log.appendChild(tableEl);
        document.getElementById('resultsCount').textContent = `Results: ${result.totalSize} (${elapsedSec}s)`;
        return;
    }

    if (!result.records && !Array.isArray(result)) {
        const pre = document.createElement("pre");
        pre.textContent = JSON.stringify(result, null, 2);
        log.appendChild(pre);
        document.getElementById('resultsCount').textContent = `Results: JSON Response (${elapsedSec}s)`;
        return;
    }

    const records = result.records || result;
    if (!records || records.length === 0) {
        const emptyEl = document.createElement("div");
        emptyEl.className = "log-line";
        emptyEl.textContent = "‚ö†Ô∏è No records returned.";
        log.appendChild(emptyEl);
        document.getElementById('resultsCount').textContent = `Results: 0 (${elapsedSec}s)`;
        return;
    }

    const headers = Object.keys(records[0]).filter(h => h !== "attributes");
    if (headers.length === 0) {
        const emptyEl = document.createElement("div");
        emptyEl.className = "log-line";
        emptyEl.textContent = "‚ö†Ô∏è No fields to display.";
        log.appendChild(emptyEl);
        return;
    }

    const headerLabels = headers.map(h => (/^expr\d+$/i.test(h) && headers.length === 1) ? "COUNT" : h);
    const tableEl = document.createElement("table");
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    
    // Add row number column header
    const rowNumTh = document.createElement("th");
    rowNumTh.textContent = "#";
    rowNumTh.style.width = "40px";
    rowNumTh.style.textAlign = "right";
    headerRow.appendChild(rowNumTh);
    
    headerLabels.forEach(lbl => { const th = document.createElement("th"); th.textContent = lbl; headerRow.appendChild(th); });
    thead.appendChild(headerRow); tableEl.appendChild(thead);

    const tbody = document.createElement("tbody");
    
    // Store references for progressive rendering
    currentTable = tableEl;
    currentTbody = tbody;
    records.forEach((rec, index) => {
        const tr = document.createElement("tr");
        
        // Add row number cell
        const rowNumTd = document.createElement("td");
        rowNumTd.textContent = index + 1;
        rowNumTd.style.textAlign = "right";
        rowNumTd.style.color = "#666";
        tr.appendChild(rowNumTd);
        
        headers.forEach(h => {
            const td = document.createElement("td");
            let val = rec[h];
            if (val === null || val === undefined) td.textContent = "";
            else if (typeof val === "object") {
                if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
            } else td.textContent = String(val);
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });

    tableEl.appendChild(tbody);
    log.appendChild(tableEl);
    
    // Update results counter - show if pagination occurred
    const totalSize = result.totalSize || records.length;
    if (totalSize > records.length) {
        document.getElementById('resultsCount').textContent = `Results: ${records.length} of ${totalSize} (${elapsedSec}s)`;
    } else {
        document.getElementById('resultsCount').textContent = `Results: ${records.length} (${elapsedSec}s)`;
    }
}

// ===== AUTOCOMPLETE FUNCTIONS =====

// Fetch and cache all SObjects
async function fetchSObjects() {
    if (sobjectsCache) return sobjectsCache;
    try {
        const result = await window.api.describeGlobal();
        sobjectsCache = result.sobjects || [];
        console.log('Cached', sobjectsCache.length, 'SObjects');
        return sobjectsCache;
    } catch (error) {
        console.error('Error fetching SObjects:', error);
        // Check if it's a config error
        if (error.message && error.message.includes('No config selected')) {
            showEnvironmentReminder();
        }
        return [];
    }
}

// Fetch and cache fields for a specific object
async function fetchObjectFields(objectName) {
    if (objectFieldsCache[objectName]) return objectFieldsCache[objectName];
    try {
        const result = await window.api.describeObject(objectName);
        objectFieldsCache[objectName] = result.fields || [];
        console.log('Cached', objectFieldsCache[objectName].length, 'fields for', objectName);
        return objectFieldsCache[objectName];
    } catch (error) {
        console.error('Error fetching fields for', objectName, ':', error);
        // Check if it's a config error
        if (error.message && error.message.includes('No config selected')) {
            showEnvironmentReminder();
        }
        return [];
    }
}

// Show reminder to select environment
function showEnvironmentReminder() {
    const log = document.getElementById('log');
    
    // Check if reminder is already displayed
    const existingReminder = log.querySelector('.env-reminder');
    if (existingReminder) return;
    
    const msg = document.createElement('div');
    msg.className = 'log-line env-reminder';
    msg.style.background = '#fff3cd';
    msg.style.color = '#856404';
    msg.style.padding = '5px';
    msg.textContent = '‚ö†Ô∏è Please select an environment first';
    log.appendChild(msg);
}

// Parse query context to determine what to suggest
function getAutocompletContext(text, cursorPos) {
    // Get text before and after cursor
    const textBeforeCursor = text.substring(0, cursorPos);
    const textAfterCursor = text.substring(cursorPos);
    const textBeforeCursorUpper = textBeforeCursor.toUpperCase();
    
    // Get current word being typed
    const wordMatch = textBeforeCursor.match(/[\w\.]+$/);
    let currentWord = wordMatch ? wordMatch[0] : '';
    
    // If typing right before a keyword, strip it from currentWord
    if (textAfterCursor.match(/^(FROM|WHERE|ORDER|GROUP|LIMIT)\b/i)) {
        const keywordMatch = currentWord.match(/^(.*?)(FROM|WHERE|ORDER|GROUP|LIMIT)$/i);
        if (keywordMatch) {
            currentWord = keywordMatch[1];
        }
    }
    
    // ===== KEYWORD SUPPRESSION =====
    // Suppress autocomplete when user is typing SOQL keywords themselves
    
    const currentWordUpper = currentWord.toUpperCase();
    const textBeforeWord = textBeforeCursorUpper.substring(0, textBeforeCursorUpper.length - currentWord.length);
    
    // Suppress when typing "BY" after ORDER/GROUP
    if (textBeforeCursorUpper.match(/\b(ORDER|GROUP)\s+B[Y]?$/i)) {
        return null;
    }
    
    // Suppress ORDER/GROUP keywords after FROM clause (e.g., "SELECT Id FROM Account Ord")
    if (currentWordUpper.match(/^(ORD|ORDE|ORDER|GRO|GROU|GROUP)$/) && textBeforeWord.match(/\bFROM\s+\w+/i)) {
        return null;
    }
    
    // Suppress general SQL keywords at start of query or after clause keywords
    const isTypingKeyword = currentWordUpper.match(/^(SEL|SELE|SELEC|SELECT|FRO|FROM|WH|WHE|WHER|WHERE|ORD|ORDE|ORDER|GRO|GROU|GROUP|LIM|LIMI|LIMIT|B|BY)$/);
    if (isTypingKeyword && (textBeforeWord.match(/^\s*$/) || textBeforeWord.match(/\b(SELECT|WHERE|AND|OR|NOT|FROM)\s*$/i))) {
        return null;
    }
    
    // ===== OBJECT NAME DETECTION =====
    // Extract current query block and find the object name from FROM clause
    
    let blockStart = 0;
    for (let i = cursorPos - 1; i >= 0; i--) {
        if (text[i] === '\n' && (i === 0 || text[i-1] === '\n')) {
            blockStart = i + 1;
            break;
        }
    }
    let blockEnd = text.length;
    for (let i = cursorPos; i < text.length; i++) {
        if (text[i] === '\n' && (i === text.length - 1 || text[i+1] === '\n')) {
            blockEnd = i;
            break;
        }
    }
    const queryBlock = text.substring(blockStart, blockEnd).toUpperCase();
    
    // Find object name from FROM clause (look ahead and in current block)
    const fromMatchAhead = textAfterCursor.toUpperCase().match(/^FROM\s+(\w+)/);
    const fromMatchInBlock = queryBlock.match(/\bFROM\s+(\w+)/);
    const objectName = fromMatchAhead ? fromMatchAhead[1] : (fromMatchInBlock ? fromMatchInBlock[1] : null);
    
    // If typing the object name after FROM, suggest objects
    if (textBeforeCursorUpper.match(/\bFROM\s*(\w*)$/)) {
        return { type: 'object', prefix: currentWord };
    }
    
    // ===== RELATIONSHIP FIELD DETECTION =====
    // Check if typing a relationship field (e.g., Account.Name)
    
    if (currentWord.includes('.')) {
        const parts = currentWord.split('.');
        if (parts.length === 2) {
            const relationshipName = parts[0];
            const fieldPrefix = parts[1];
            
            // We need the base object's fields to find the relationship
            if (objectName) {
                return {
                    type: 'relationship-field',
                    baseObjectName: objectName,
                    relationshipName: relationshipName,
                    prefix: fieldPrefix
                };
            }
        }
    }
    
    // ===== CLAUSE DETECTION =====
    // Determine which SOQL clause we're in and whether to suggest fields
    
    if (objectName) {
        const selectMatch = textBeforeCursorUpper.match(/\bSELECT\b(.*)$/);
        const whereMatch = textBeforeCursorUpper.match(/\bWHERE\b(.*)$/);
        const orderByMatch = textBeforeCursorUpper.match(/\bORDER\s+BY\b(.*)$/);
        const groupByMatch = textBeforeCursorUpper.match(/\bGROUP\s+BY\b(.*)$/);
        
        // SELECT clause - suggest fields before FROM or if FROM is ahead
        if (selectMatch && (!selectMatch[1].includes('FROM') || fromMatchAhead)) {
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
        
        // ORDER BY clause - handle comma-separated fields and ASC/DESC keywords
        if (orderByMatch) {
            const textAfterOrderBy = orderByMatch[1];
            const textBeforeWord = textAfterOrderBy.substring(0, textAfterOrderBy.length - currentWord.length);
            
            // After comma - show field suggestions
            if (textBeforeWord.match(/,\s*$/)) {
                return { type: 'field', objectName: objectName, prefix: currentWord };
            }
            
            // Typing ASC/DESC - suppress
            if (currentWord.toLowerCase().match(/^(a|as|asc|d|de|des|desc)$/)) {
                return null;
            }
            
            // After field name with space (before ASC/DESC) - suppress
            if (textBeforeWord.match(/\w\s+$/) && currentWord === '') {
                return null;
            }
            
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
        
        // WHERE clause - handle operators, values, quotes, and logical operators
        if (whereMatch) {
            const textAfterWhere = whereMatch[1];
            const textBeforeWord = textAfterWhere.substring(0, textAfterWhere.length - currentWord.length);
            
            // After closing quote - suppress until AND/OR typed
            if (textBeforeWord.match(/['"]\s*$/) && currentWord === '') {
                return null;
            }
            
            // After comparison operator - suppress (user is typing a value)
            if (textAfterWhere.match(/(=|!=|<|>|<=|>=|\bLIKE|\bIN|\bNOT\s+IN)\s*['"]?[\w\s]*$/i)) {
                return null;
            }
            
            // Typing logical operators (AND/OR/NOT) after a condition - suppress
            const hasLogicalKeywordBefore = textBeforeWord.match(/\b(AND|OR|NOT)\s+$/i);
            if (!hasLogicalKeywordBefore && currentWord.toLowerCase().match(/^(a|an|and|o|or|n|no|not)$/i)) {
                if (textBeforeWord.trim().match(/(['"\d\w]\s*$|\)\s*$)/)) {
                    return null;
                }
            }
            
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
        
        // GROUP BY clause - suggest fields
        if (groupByMatch) {
            return { type: 'field', objectName: objectName, prefix: currentWord };
        }
    }
    return null;
}

// Show autocomplete dropdown with suggestions
function showAutocomplete(suggestions, prefix, isField = false) {
    const dropdown = document.getElementById('autocomplete');
    const editor = document.getElementById('editor');
    
    if (!suggestions || suggestions.length === 0) {
        hideAutocomplete();
        return;
    }
    
    // For fields, also include relationship names as separate suggestions
    let allSuggestions = [...suggestions];
    if (isField) {
        const seenRelationships = new Set();
        suggestions.forEach(field => {
            // Only add relationship names from lookup/reference fields
            if (field.type === 'reference' && field.relationshipName && 
                field.referenceTo && field.referenceTo.length > 0 &&
                !seenRelationships.has(field.relationshipName)) {
                
                seenRelationships.add(field.relationshipName);
                
                // Add relationship name as a separate suggestion
                allSuggestions.push({
                    name: field.relationshipName,
                    label: `${field.label} relationship`,
                    type: 'relationship',
                    referenceTo: field.referenceTo,
                    isRelationship: true
                });
            }
        });
    }
    
    // Filter suggestions by prefix (partial match anywhere in the name)
    const filtered = allSuggestions.filter(item => {
        const name = item.name;
        return name.toLowerCase().includes(prefix.toLowerCase());
    });
    
    if (filtered.length === 0) {
        hideAutocomplete();
        return;
    }
    
    // Sort fields by priority
    if (isField) {
        filtered.sort((a, b) => {
            const lowerPrefix = prefix.toLowerCase();
            const aStartsWith = a.name.toLowerCase().startsWith(lowerPrefix);
            const bStartsWith = b.name.toLowerCase().startsWith(lowerPrefix);
            
            // Prefix matches come first
            if (aStartsWith && !bStartsWith) return -1;
            if (!aStartsWith && bStartsWith) return 1;
            
            const getPriority = (field) => {
                const name = field.name;
                // Top tier: Id, Name
                if (name === 'Id' || name === 'Name') return 1;
                // Second tier: audit fields, ownership
                if (['CreatedDate', 'CreatedById', 'LastModifiedDate', 'LastModifiedById', 
                     'SystemModstamp', 'OwnerId', 'RecordTypeId', 'IsDeleted'].includes(name)) return 2;
                // Third tier: everything else
                if (!field.isRelationship) return 3;
                // Bottom tier: Relationship names (for traversal like Account, Owner)
                return 4;
            };
            
            const priorityA = getPriority(a);
            const priorityB = getPriority(b);
            
            if (priorityA !== priorityB) {
                return priorityA - priorityB;
            }
            
            // Within same priority, sort alphabetically
            return a.name.localeCompare(b.name);
        });
    } else {
        // Sort objects - prefix matches first, then alphabetically
        filtered.sort((a, b) => {
            const lowerPrefix = prefix.toLowerCase();
            const aStartsWith = a.name.toLowerCase().startsWith(lowerPrefix);
            const bStartsWith = b.name.toLowerCase().startsWith(lowerPrefix);
            
            // Prefix matches come first
            if (aStartsWith && !bStartsWith) return -1;
            if (!aStartsWith && bStartsWith) return 1;
            
            // Within same match type, sort alphabetically
            return a.name.localeCompare(b.name);
        });
    }
    
    autocompleteItems = filtered;
    autocompleteSelectedIndex = 0;
    
    // Build dropdown HTML
    dropdown.innerHTML = filtered.map((item, index) => {
        let label, hint;
        if (isField) {
            // For fields, show API name as main, always show friendly label as hint
            label = item.name;
            if (item.isRelationship) {
                // For relationship names, add indicator and show related object
                const relatedObj = item.referenceTo ? item.referenceTo[0] : '';
                hint = ` <span class="autocomplete-relationship">‚Üí ${relatedObj}</span>`;
            } else {
                hint = item.label ? `<span class="autocomplete-hint">${item.label}</span>` : '';
            }
        } else {
            // For objects, show API name as main, always show friendly label as hint
            label = item.name;
            hint = item.label ? `<span class="autocomplete-hint">${item.label}</span>` : '';
        }
        return `<div class="autocomplete-item${index === 0 ? ' selected' : ''}" data-index="${index}">${label}${hint}</div>`;
    }).join('');
    
    // Position dropdown below cursor
    const coords = getCaretCoordinates(editor);
    dropdown.style.left = coords.left + 'px';
    dropdown.style.top = coords.top + 'px';
    dropdown.style.display = 'block';
    autocompleteVisible = true;
    
    // Adjust position if dropdown would go off-screen
    const dropdownRect = dropdown.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Check if dropdown extends beyond right edge
    if (dropdownRect.right > viewportWidth) {
        dropdown.style.left = (viewportWidth - dropdownRect.width - 10) + 'px';
    }
    
    // Check if dropdown extends beyond bottom edge
    if (dropdownRect.bottom > viewportHeight) {
        // Position above cursor instead
        dropdown.style.top = (coords.top - dropdownRect.height - 20) + 'px';
    }
    
    // Add click handlers
    dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
        item.addEventListener('click', () => {
            const index = parseInt(item.dataset.index);
            selectAutocompleteItem(index);
        });
    });
}

// Hide autocomplete dropdown
function hideAutocomplete() {
    const dropdown = document.getElementById('autocomplete');
    dropdown.style.display = 'none';
    dropdown.innerHTML = '';
    autocompleteVisible = false;
    autocompleteSelectedIndex = -1;
    autocompleteItems = [];
}

// Select an autocomplete item
function selectAutocompleteItem(index) {
    if (index < 0 || index >= autocompleteItems.length) return;
    
    const editor = document.getElementById('editor');
    const cursorPos = editor.selectionStart;
    const text = editor.value;
    
    // Find the start of the current word
    const beforeCursor = text.substring(0, cursorPos);
    const wordMatch = beforeCursor.match(/\w+$/);
    const wordStart = wordMatch ? cursorPos - wordMatch[0].length : cursorPos;
    
    // Select the current word so we can replace it
    editor.selectionStart = wordStart;
    editor.selectionEnd = cursorPos;
    editor.focus();
    
    // Insert the selected name, which preserves undo history
    const selectedName = autocompleteItems[index].name;
    document.execCommand('insertText', false, selectedName);
    
    hideAutocomplete();
}

// Move selection in autocomplete dropdown
function moveAutocompleteSelection(direction) {
    if (!autocompleteVisible || autocompleteItems.length === 0) return;
    
    // Update index
    autocompleteSelectedIndex += direction;
    if (autocompleteSelectedIndex < 0) autocompleteSelectedIndex = autocompleteItems.length - 1;
    if (autocompleteSelectedIndex >= autocompleteItems.length) autocompleteSelectedIndex = 0;
    
    // Update UI
    const dropdown = document.getElementById('autocomplete');
    const items = dropdown.querySelectorAll('.autocomplete-item');
    items.forEach((item, index) => {
        if (index === autocompleteSelectedIndex) {
            item.classList.add('selected');
            item.scrollIntoView({ block: 'nearest' });
        } else {
            item.classList.remove('selected');
        }
    });
}

// Get cursor coordinates in textarea for positioning dropdown
function getCaretCoordinates(element) {
    const rect = element.getBoundingClientRect();
    const style = window.getComputedStyle(element);
    const lineHeight = parseInt(style.lineHeight) || 20;
    const paddingTop = parseInt(style.paddingTop) || 0;
    const paddingLeft = parseInt(style.paddingLeft) || 0;
    
    // Create a mirror div to measure text position
    const mirror = document.createElement('div');
    mirror.style.position = 'absolute';
    mirror.style.visibility = 'hidden';
    mirror.style.whiteSpace = 'pre-wrap';
    mirror.style.wordWrap = 'break-word';
    mirror.style.font = style.font;
    mirror.style.padding = style.padding;
    mirror.style.width = rect.width + 'px';
    document.body.appendChild(mirror);
    
    // Get text before cursor
    const textBeforeCursor = element.value.substring(0, element.selectionStart);
    mirror.textContent = textBeforeCursor;
    
    // Add a span at the cursor position
    const span = document.createElement('span');
    span.textContent = '|';
    mirror.appendChild(span);
    
    const spanRect = span.getBoundingClientRect();
    const mirrorRect = mirror.getBoundingClientRect();
    
    document.body.removeChild(mirror);
    
    return {
        left: rect.left + (spanRect.left - mirrorRect.left) + paddingLeft,
        top: rect.top + (spanRect.top - mirrorRect.top) + paddingTop + lineHeight
    };
}

// Handle autocomplete trigger on editor input
async function handleEditorInput(event) {
    // Check if autocomplete is enabled
    if (!autocompleteEnabled) {
        hideAutocomplete();
        return;
    }
    
    const editor = document.getElementById('editor');
    const cursorPos = editor.selectionStart;
    const text = editor.value;
    
    // Get context
    const context = getAutocompletContext(text, cursorPos);
    
    if (!context) {
        hideAutocomplete();
        return;
    }
    
    // Fetch suggestions based on context
    if (context.type === 'object') {
        const sobjects = await fetchSObjects();
        showAutocomplete(sobjects, context.prefix, false);
    } else if (context.type === 'field') {
        const fields = await fetchObjectFields(context.objectName);
        showAutocomplete(fields, context.prefix, true);
    } else if (context.type === 'relationship-field') {
        // Resolve the related object from the relationship field
        const baseFields = await fetchObjectFields(context.baseObjectName);
        
        // Find the relationship field
        const relationshipField = baseFields.find(f => 
            f.relationshipName && f.relationshipName.toLowerCase() === context.relationshipName.toLowerCase()
        );
        
        if (relationshipField && relationshipField.referenceTo && relationshipField.referenceTo.length > 0) {
            const relatedObjectName = relationshipField.referenceTo[0];
            const relatedFields = await fetchObjectFields(relatedObjectName);
            showAutocomplete(relatedFields, context.prefix, true);
        } else {
            hideAutocomplete();
        }
    }
}

// Handle keyboard navigation in autocomplete
function handleEditorKeydown(event) {
    // Allow standard undo/redo
    if ((event.ctrlKey || event.metaKey) && (event.key.toLowerCase() === 'z' || event.key.toLowerCase() === 'y')) {
        return; // Let browser handle undo/redo
    }
    
    if (autocompleteVisible) {
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            moveAutocompleteSelection(1);
            return;
        }
        if (event.key === 'ArrowUp') {
            event.preventDefault();
            moveAutocompleteSelection(-1);
            return;
        }
        if (event.key === 'PageDown') {
            event.preventDefault();
            moveAutocompleteSelection(5);
            return;
        }
        if (event.key === 'PageUp') {
            event.preventDefault();
            moveAutocompleteSelection(-5);
            return;
        }
        if (event.key === 'Enter' || event.key === 'Tab') {
            event.preventDefault();
            selectAutocompleteItem(autocompleteSelectedIndex);
            return;
        }
        if (event.key === ',') {
            event.preventDefault();
            selectAutocompleteItem(autocompleteSelectedIndex);
            // Insert comma after selection
            setTimeout(() => {
                document.execCommand('insertText', false, ',');
            }, 0);
            return;
        }
        if (event.key === '.') {
            // Only allow period completion on relationship fields
            const selectedItem = autocompleteItems[autocompleteSelectedIndex];
            if (selectedItem && selectedItem.isRelationship) {
                event.preventDefault();
                selectAutocompleteItem(autocompleteSelectedIndex);
                // Insert period after selection
                setTimeout(() => {
                    document.execCommand('insertText', false, '.');
                }, 0);
                return;
            }
            // Otherwise, let the period character pass through normally (hide autocomplete)
            hideAutocomplete();
            return;
        }
        if (event.key === 'Escape') {
            event.preventDefault();
            hideAutocomplete();
            return;
        }
    }
}

// Initialize autocomplete
function initAutocomplete() {
    const editor = document.getElementById('editor');
    editor.addEventListener('input', handleEditorInput);
    editor.addEventListener('keydown', handleEditorKeydown);
    
    // Restore autocomplete enabled state from localStorage
    const checkbox = document.getElementById('autocompleteEnabled');
    checkbox.checked = autocompleteEnabled;
    
    // Hide autocomplete when clicking outside
    document.addEventListener('click', (event) => {
        if (!event.target.closest('#autocomplete') && event.target.id !== 'editor') {
            hideAutocomplete();
        }
    });
}

document.addEventListener('DOMContentLoaded',()=>{ 
    if(window.api) {
        loadEnvironments();
        initAutocomplete();
    }
});
</script>
</body>
</html>
