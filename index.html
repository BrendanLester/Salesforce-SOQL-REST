<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Playforce Query</title>
<style>
body { margin:0; height:100vh; display:flex; flex-direction:column; font-family:sans-serif; }
#toolbar { display:flex; gap:10px; padding:8px; background:#e8e8e8; border-bottom:1px solid #ccc; }
#toolbar button { padding:6px 12px; background:#0066cc; color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px; }
#toolbar button:hover { background:#0052a3; }
#toolbar input[type="file"] { display:none; }
#top, #bottom { flex:1; overflow:hidden; }
#splitter { height:5px; background:#888; cursor:row-resize; }
textarea { width:100%; height:100%; resize:none; font-family:monospace; font-size:14px; box-sizing:border-box; padding:8px; overflow:auto; }
textarea::selection { background:#ffd700; color:#000; }
#log { padding:8px; font-family:monospace; font-size:14px; overflow:auto; flex:1; outline:none; }
#log:focus { box-shadow: inset 0 0 0 2px #0066cc; }
.log-line { padding:2px 0; border-bottom:1px solid #ccc; }
table { width:100%; border-collapse:collapse; margin-top:4px; font-family:monospace; font-size:14px; }
th, td { border:1px solid #ccc; padding:4px 8px; text-align:left; }
th { background:#eee; }
tr:nth-child(even) { background:#f9f9f9; }
tr:hover { background:#fffae6; }
.keyword { color:#d73a49; font-weight:bold; }

#results-header { display:flex; justify-content:flex-end; padding:4px 8px; border-bottom:1px solid #ccc; background:#f5f5f5; }
#copyResultsBtn { padding:4px 8px; font-size:12px; cursor:pointer; }
#stopQueryBtn { padding:4px 8px; font-size:12px; cursor:pointer; background:#dc3545; color:white; border:none; border-radius:4px; margin-right:8px; display:none; }
#stopQueryBtn:hover { background:#c82333; }

.search-box { position:absolute; top:10px; right:10px; background:#fff; border:2px solid #0066cc; border-radius:4px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:1000; display:none; }
.search-box input { border:1px solid #ccc; padding:4px; margin-right:4px; font-size:12px; }
.search-box button { background:#0066cc; color:white; border:none; padding:4px 8px; cursor:pointer; font-size:12px; }
.search-box button:hover { background:#0052a3; }
.search-highlight { background:#ffff00; color:#000; }
.search-current { background:#ff6600; color:#fff; }
</style>
</head>
<body>
<div id="toolbar">
    <button onclick="saveSession()">üíæ Save Session</button>
    <button onclick="document.getElementById('fileInput').click()">üìÇ Load Session</button>
    <input type="file" id="fileInput" accept=".json" onchange="loadSession(event)">
    
    <select id="envSelector" onchange="changeEnvironment()" style="margin-left:20px; padding:6px 12px; border-radius:4px; border:1px solid #ccc;">
        <option value="">Select Environment</option>
    </select>
    
    <span style="margin-left:auto; font-size:12px; color:#666;">Press Ctrl+E on a query block to execute SOQL or REST</span>
</div>

<div id="top" style="background:#f0f0f0; position:relative;">
<textarea id="editor" placeholder="Type SOQL queries or REST paths here..."></textarea>
<div id="editorSearch" class="search-box">
    <input type="text" placeholder="Search..." id="editorSearchInput">
    <span id="editorMatchCount" style="font-size:11px; color:#666; margin-right:4px;"></span>
    <button onclick="findNext('editor')" title="Find Next (Enter)">‚Üì</button>
    <button onclick="findPrev('editor')" title="Find Previous (Shift+Enter)">‚Üë</button>
    <button onclick="closeSearch('editor')" title="Close (Escape)">‚úï</button>
</div>
</div>
<div id="splitter"></div>
<div id="bottom" style="background:#fff; display:flex; flex-direction:column; position:relative;">
    <div id="results-header">
        <span id="resultsCount" style="font-size:12px; color:#666; margin-right:auto;"></span>
        <button id="stopQueryBtn" onclick="stopQuery()">‚èπ Stop Query</button>
        <button id="copyResultsBtn">üìã Copy Results</button>
    </div>
    <div id="log" tabindex="0">üëâ Select an environment first, then press Ctrl+E on a block above to execute.</div>
    <div id="logSearch" class="search-box">
        <input type="text" placeholder="Search..." id="logSearchInput">
        <span id="logMatchCount" style="font-size:11px; color:#666; margin-right:4px;"></span>
        <button onclick="findNext('log')" title="Find Next (Enter)">‚Üì</button>
        <button onclick="findPrev('log')" title="Find Previous (Shift+Enter)">‚Üë</button>
        <button onclick="closeSearch('log')" title="Close (Escape)">‚úï</button>
    </div>
</div>

<script>
// Highlight SOQL keywords
function highlightSOQL(query) {
    const keywords = /\b(SELECT|FROM|WHERE|LIMIT|ORDER BY|GROUP BY|AND|OR|NOT|NULL)\b/gi;
    return query.replace(keywords, '<span class="keyword">$1</span>');
}

// Environment functions
async function loadEnvironments() {
    if (!window.api?.listConfigs) return;
    const configs = await window.api.listConfigs();
    const selector = document.getElementById('envSelector');
    while (selector.children.length > 1) selector.removeChild(selector.lastChild);
    if (!configs.length) {
        const opt = document.createElement('option'); opt.textContent='No configs found'; opt.disabled=true; selector.appendChild(opt);
    } else {
        configs.forEach(c=>{ const opt=document.createElement('option'); opt.value=c; opt.textContent=c; selector.appendChild(opt); });
    }
}

async function changeEnvironment() {
    const sel=document.getElementById('envSelector'); if(!sel.value) return;
    try {
        const success = await window.api.setConfigFile(sel.value);
        if(success){
            log.innerHTML='';
            const msg = document.createElement('div');
            msg.className='log-line';
            msg.style.background="#d1ecf1"; msg.style.color="#0c5460"; msg.style.padding="5px";
            msg.textContent=`üîÑ Switched to ${sel.value} environment`;
            log.appendChild(msg);
            document.title = `Playforce Query - ${sel.value}`;
            
            // Auto-authenticate based on grant type
            await autoAuthenticate();
        } else alert('Failed to switch environment');
    } catch(err){ alert(err.message); }
}

// Auto-authenticate based on grant type
async function autoAuthenticate() {
    const log = document.getElementById('log');
    
    try {
        // First check if we already have a valid token for this environment
        const hasToken = await window.api.hasValidToken();
        
        if (hasToken) {
            // Already authenticated - just show ready message
            const readyMsg = document.createElement('div');
            readyMsg.className = 'log-line';
            readyMsg.style.background = "#d4edda";
            readyMsg.style.color = "#155724";
            readyMsg.style.padding = "5px";
            readyMsg.textContent = `‚úÖ Using cached token - Ready to execute queries`;
            log.appendChild(readyMsg);
            return;
        }
        
        // No cached token, try authentication (will attempt client_credentials if no username/password)
        const result = await window.api.tryAuthenticate();
        
        if (result.success) {
            // Authentication successful
            const readyMsg = document.createElement('div');
            readyMsg.className = 'log-line';
            readyMsg.style.background = "#d4edda";
            readyMsg.style.color = "#155724";
            readyMsg.style.padding = "5px";
            const method = result.method === 'client_credentials' ? 'client credentials' : 'password';
            readyMsg.textContent = `‚úÖ Authenticated with ${method} - Ready to execute queries`;
            log.appendChild(readyMsg);
        } else if (result.needsOAuth) {
            // Client credentials failed, need OAuth
            const infoMsg = document.createElement('div');
            infoMsg.className = 'log-line';
            infoMsg.style.background = "#d1ecf1";
            infoMsg.style.color = "#0c5460";
            infoMsg.style.padding = "5px";
            infoMsg.textContent = 'üîê Client credentials not available, starting OAuth flow...';
            log.appendChild(infoMsg);
            
            // Start OAuth flow
            const oauthResult = await window.api.startOAuthFlow();
            
            if (!oauthResult.success) {
                throw new Error(oauthResult.error);
            }
            
            const waitingMsg = document.createElement('div');
            waitingMsg.className = 'log-line';
            waitingMsg.style.background = "#fff3cd";
            waitingMsg.style.color = "#856404";
            waitingMsg.style.padding = "5px";
            waitingMsg.textContent = '‚è≥ Please authenticate in your browser...';
            log.appendChild(waitingMsg);
        } else {
            // Some other error
            throw new Error(result.error || 'Authentication failed');
        }
    } catch (error) {
        const errorMsg = document.createElement('div');
        errorMsg.className = 'log-line';
        errorMsg.style.background = "#f8d7da";
        errorMsg.style.color = "#721c24";
        errorMsg.style.padding = "5px";
        errorMsg.textContent = `‚ùå Authentication Error: ${error.message}`;
        log.appendChild(errorMsg);
    }
}

// Setup OAuth callback handlers
if (window.api?.onOAuthCallback) {
    window.api.onOAuthCallback(async (authCode) => {
        const log = document.getElementById('log');
        
        try {
            const exchangeMsg = document.createElement('div');
            exchangeMsg.className = 'log-line';
            exchangeMsg.style.background = "#d1ecf1";
            exchangeMsg.style.color = "#0c5460";
            exchangeMsg.style.padding = "5px";
            exchangeMsg.textContent = 'üîÑ Exchanging authorization code for access token...';
            log.appendChild(exchangeMsg);
            
            const result = await window.api.exchangeAuthCode(authCode, 'http://localhost:8888/oauth/callback');
            
            if (result.success) {
                const successMsg = document.createElement('div');
                successMsg.className = 'log-line';
                successMsg.style.background = "#d4edda";
                successMsg.style.color = "#155724";
                successMsg.style.padding = "5px";
                successMsg.textContent = '‚úÖ OAuth authentication successful! You can now execute queries.';
                log.appendChild(successMsg);
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            const errorMsg = document.createElement('div');
            errorMsg.className = 'log-line';
            errorMsg.style.background = "#f8d7da";
            errorMsg.style.color = "#721c24";
            errorMsg.style.padding = "5px";
            errorMsg.textContent = `‚ùå Token Exchange Error: ${error.message}`;
            log.appendChild(errorMsg);
        }
    });
}

if (window.api?.onOAuthError) {
    window.api.onOAuthError((error) => {
        const log = document.getElementById('log');
        const errorMsg = document.createElement('div');
        errorMsg.className = 'log-line';
        errorMsg.style.background = "#f8d7da";
        errorMsg.style.color = "#721c24";
        errorMsg.style.padding = "5px";
        errorMsg.textContent = `‚ùå OAuth Error: ${error.error} - ${error.error_description || 'Unknown error'}`;
        log.appendChild(errorMsg);
    });
}

// Session save/load
function saveSession() {
    const blob=new Blob([JSON.stringify({queries:editor.value,timestamp:new Date().toISOString(),version:"1.0"},null,2)],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`soql-session-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`; a.click(); URL.revokeObjectURL(a.href);
}
function loadSession(e){
    const file=e.target.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=function(ev){
        try{
            const s=JSON.parse(ev.target.result);
            if(s.queries) editor.value=s.queries;
            log.innerHTML=''; const msg=document.createElement('div');
            msg.className='log-line'; msg.style.background="#d4edda"; msg.style.color="#155724"; msg.style.padding="5px";
            msg.textContent=`‚úÖ Session loaded from ${s.timestamp ? new Date(s.timestamp).toLocaleString() : 'unknown date'}`;
            log.appendChild(msg);
        } catch(err){ alert(err.message); }
    }; reader.readAsText(file); e.target.value='';
}

// Splitter (fixed version using flex-basis)
const splitter = document.getElementById("splitter"),
      topDiv = document.getElementById("top"),
      bottomDiv = document.getElementById("bottom");

let isDragging = false;

splitter.addEventListener("mousedown", () => {
    isDragging = true;
    document.body.style.cursor = "row-resize";
    topDiv.style.flex = "none";
    bottomDiv.style.flex = "none";
});

document.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const offsetY = e.clientY;
    const toolbarHeight = document.getElementById("toolbar").offsetHeight;
    const totalHeight = window.innerHeight - toolbarHeight - splitter.offsetHeight;

    const topHeight = Math.max(50, offsetY - toolbarHeight);
    const bottomHeight = Math.max(50, totalHeight - (offsetY - toolbarHeight));

    topDiv.style.height = `${topHeight}px`;
    bottomDiv.style.height = `${bottomHeight}px`;
});

document.addEventListener("mouseup", () => {
    if (!isDragging) return;
    isDragging = false;
    document.body.style.cursor = "default";
});

const editor = document.getElementById("editor");
const log = document.getElementById("log");

// Copy button
document.getElementById('copyResultsBtn').addEventListener('click',()=>{ if(!log.innerText) return; navigator.clipboard.writeText(log.innerText).catch(err=>alert('‚ùå Failed to copy results')); });

// Ctrl+A in log - select all results content
log.addEventListener('keydown',e=>{ 
    if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='a'){ 
        e.preventDefault(); 
        const r=document.createRange(); 
        r.selectNodeContents(log); 
        const s=window.getSelection(); 
        s.removeAllRanges(); 
        s.addRange(r); 
    } 
});

// Auto-focus log when clicked
log.addEventListener('click', () => log.focus());

// Global Escape handler to close search boxes or stop query
document.addEventListener('keydown', e => {
    if(e.key === 'Escape') {
        const editorSearch = document.getElementById('editorSearch');
        const logSearch = document.getElementById('logSearch');
        
        // Priority 1: Close search boxes if open
        if(editorSearch.style.display === 'block') {
            closeSearch('editor');
        } else if(logSearch.style.display === 'block') {
            closeSearch('log');
        } else if(currentQueryId) {
            // Priority 2: Stop running query if no search boxes are open
            stopQuery();
        }
    }
});

// Search functionality
let currentMatches = {};
let currentMatchIndex = {};

function openSearch(pane) {
    const searchBox = document.getElementById(pane === 'editor' ? 'editorSearch' : 'logSearch');
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    searchBox.style.display = 'block';
    input.focus();
}

function closeSearch(pane) {
    const searchBox = document.getElementById(pane === 'editor' ? 'editorSearch' : 'logSearch');
    searchBox.style.display = 'none';
    clearHighlights(pane);
}

function clearHighlights(pane) {
    if(pane === 'editor') {
        // For textarea, we can't highlight directly, so we'll just clear selection
        editor.setSelectionRange(0, 0);
        document.getElementById('editorMatchCount').textContent = '';
    } else {
        // For log, remove highlight spans
        const highlights = log.querySelectorAll('.search-highlight, .search-current');
        highlights.forEach(span => {
            const parent = span.parentNode;
            parent.replaceChild(document.createTextNode(span.textContent), span);
            parent.normalize();
        });
        document.getElementById('logMatchCount').textContent = '';
    }
    currentMatches[pane] = [];
    currentMatchIndex[pane] = -1;
}

function findInEditor(searchText, direction = 1) {
    if(!searchText) return;
    
    const text = editor.value.toLowerCase();
    const searchLower = searchText.toLowerCase();
    const matches = [];
    let pos = 0;
    
    // Find all matches
    while((pos = text.indexOf(searchLower, pos)) !== -1) {
        matches.push(pos);
        pos++;
    }
    
    if(matches.length === 0) return;
    
    // Initialize or update current match index
    if(!currentMatches['editor'] || currentMatches['editor'].searchText !== searchText) {
        currentMatches['editor'] = { matches: matches, searchText: searchText };
        currentMatchIndex['editor'] = 0;
    } else {
        const currentPos = editor.selectionStart;
        let nearestIndex = 0;
        
        // Find current position in matches
        for(let i = 0; i < matches.length; i++) {
            if(matches[i] >= currentPos) {
                nearestIndex = i;
                break;
            }
        }
        
        if(direction > 0) {
            currentMatchIndex['editor'] = (nearestIndex < matches.length - 1) ? nearestIndex + 1 : 0;
        } else {
            currentMatchIndex['editor'] = (nearestIndex > 0) ? nearestIndex - 1 : matches.length - 1;
        }
    }
    
    const matchPos = matches[currentMatchIndex['editor']];
    editor.setSelectionRange(matchPos, matchPos + searchText.length);
    editor.focus();
    
    // Update match counter
    const counter = document.getElementById('editorMatchCount');
    counter.textContent = `${currentMatchIndex['editor'] + 1} of ${matches.length}`;
    
    // Scroll to the selection in textarea - use a more reliable method
    setTimeout(() => {
        const textBeforeMatch = editor.value.substring(0, matchPos);
        const lines = textBeforeMatch.split('\n');
        const lineNumber = lines.length - 1;
        const computedStyle = getComputedStyle(editor);
        const lineHeight = parseFloat(computedStyle.lineHeight) || parseFloat(computedStyle.fontSize) * 1.2 || 16;
        const targetScrollTop = lineNumber * lineHeight - (editor.clientHeight / 2);
        editor.scrollTop = Math.max(0, targetScrollTop);
    }, 10);
}

function findInLog(searchText, direction = 1) {
    if(!searchText) return;
    
    // Only rebuild matches if search text changed
    if(!currentMatches['log'] || currentMatches['log'].searchText !== searchText) {
        clearHighlights('log');
        const text = log.textContent;
        const regex = new RegExp(escapeRegex(searchText), 'gi');
        let match;
        const matches = [];
        
        while((match = regex.exec(text)) !== null) {
            matches.push({start: match.index, end: match.index + match[0].length});
        }
        
        if(matches.length === 0) return;
        
        currentMatches['log'] = { matches: matches, searchText: searchText };
        currentMatchIndex['log'] = 0;
    } else {
        // Navigate through existing matches
        const matches = currentMatches['log'].matches;
        currentMatchIndex['log'] += direction;
        if(currentMatchIndex['log'] >= matches.length) currentMatchIndex['log'] = 0;
        if(currentMatchIndex['log'] < 0) currentMatchIndex['log'] = matches.length - 1;
    }
    
    highlightLogMatches(searchText, currentMatchIndex['log']);
    
    // Update match counter
    const counter = document.getElementById('logMatchCount');
    const matches = currentMatches['log'].matches;
    counter.textContent = `${currentMatchIndex['log'] + 1} of ${matches.length}`;
}

function highlightLogMatches(searchText, currentIndex) {
    // Check if highlights already exist
    const existingHighlights = log.querySelectorAll('.search-highlight, .search-current');
    
    if(existingHighlights.length === 0) {
        // First time highlighting - walk through text nodes only
        const regex = new RegExp(escapeRegex(searchText), 'gi');
        let matchIndex = 0;
        
        function highlightTextNode(node) {
            if(node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent;
                const matches = [];
                let match;
                regex.lastIndex = 0;
                while((match = regex.exec(text)) !== null) {
                    matches.push({ start: match.index, end: match.index + match[0].length, text: match[0] });
                }
                
                if(matches.length > 0) {
                    const fragment = document.createDocumentFragment();
                    let lastEnd = 0;
                    
                    matches.forEach(m => {
                        if(m.start > lastEnd) {
                            fragment.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
                        }
                        
                        const span = document.createElement('span');
                        span.className = matchIndex === currentIndex ? 'search-current' : 'search-highlight';
                        if(matchIndex === currentIndex) {
                            span.id = 'current-search-match';
                        }
                        span.textContent = m.text;
                        fragment.appendChild(span);
                        
                        lastEnd = m.end;
                        matchIndex++;
                    });
                    
                    if(lastEnd < text.length) {
                        fragment.appendChild(document.createTextNode(text.substring(lastEnd)));
                    }
                    
                    node.parentNode.replaceChild(fragment, node);
                }
            } else if(node.nodeType === Node.ELEMENT_NODE) {
                // Skip search highlight spans
                if(!node.classList.contains('search-highlight') && !node.classList.contains('search-current')) {
                    Array.from(node.childNodes).forEach(child => highlightTextNode(child));
                }
            }
        }
        
        highlightTextNode(log);
    } else {
        // Update existing highlights - just change classes
        existingHighlights.forEach((span, index) => {
            span.className = index === currentIndex ? 'search-current' : 'search-highlight';
            if(index === currentIndex) {
                span.id = 'current-search-match';
            } else {
                span.removeAttribute('id');
            }
        });
    }
    
    // Scroll to current match
    setTimeout(() => {
        const currentMatch = document.getElementById('current-search-match');
        if(currentMatch) {
            currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        }
    }, 10);
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function findNext(pane) {
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    const searchText = input.value.trim();
    if(!searchText) return;
    
    if(pane === 'editor') {
        findInEditor(searchText, 1);
    } else {
        findInLog(searchText, 1);
    }
}

function findPrev(pane) {
    const input = document.getElementById(pane === 'editor' ? 'editorSearchInput' : 'logSearchInput');
    const searchText = input.value.trim();
    if(!searchText) return;
    
    if(pane === 'editor') {
        findInEditor(searchText, -1);
    } else {
        findInLog(searchText, -1);
    }
}

// Ctrl+F handlers for both panes
editor.addEventListener('keydown', e => {
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearch('editor');
    }
});

log.addEventListener('keydown', e => {
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearch('log');
    }
});

// Search input handlers
document.getElementById('editorSearchInput').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
        e.preventDefault();
        if(e.shiftKey) {
            findPrev('editor');
        } else {
            findNext('editor');
        }
    } else if(e.key === 'Escape') {
        closeSearch('editor');
    }
});

document.getElementById('editorSearchInput').addEventListener('input', e => {
    const searchText = e.target.value.trim();
    if(searchText) {
        currentMatches['editor'] = null; // Reset to trigger new search
        findInEditor(searchText, 1);
    } else {
        clearHighlights('editor');
    }
});

document.getElementById('logSearchInput').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
        e.preventDefault();
        if(e.shiftKey) {
            findPrev('log');
        } else {
            findNext('log');
        }
    } else if(e.key === 'Escape') {
        closeSearch('log');
    }
});

document.getElementById('logSearchInput').addEventListener('input', e => {
    const searchText = e.target.value.trim();
    if(searchText) {
        currentMatches['log'] = null; // Reset to trigger new search
        findInLog(searchText, 1);
    } else {
        clearHighlights('log');
    }
});

// Global variables to track current query and table for progressive rendering
let currentQueryId = null;
let currentTable = null;
let currentTbody = null;

// Stop query function
async function stopQuery() {
    if (!currentQueryId) return;
    
    try {
        console.log('Stopping query:', currentQueryId);
        await window.api.abortQuery(currentQueryId);
        currentQueryId = null;
    } catch (error) {
        console.error('Error stopping query:', error);
    }
}

// Listen for pagination progress events
if(window.api?.onSOQLProgress) {
    window.api.onSOQLProgress((progress) => {
        console.log('Progress update:', progress);
        
        if (!progress.records || progress.records.length === 0) return;
        
        const headers = Object.keys(progress.records[0]).filter(h => h !== "attributes");
        
        // If table doesn't exist yet, create it with first batch
        if (!currentTable || !currentTbody) {
            const headerLabels = headers.map(h => (/^expr\d+$/i.test(h) && headers.length === 1) ? "COUNT" : h);
            const tableEl = document.createElement("table");
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");
            
            // Add row number column header
            const rowNumTh = document.createElement("th");
            rowNumTh.textContent = "#";
            rowNumTh.style.width = "40px";
            rowNumTh.style.textAlign = "right";
            headerRow.appendChild(rowNumTh);
            
            headerLabels.forEach(lbl => { const th = document.createElement("th"); th.textContent = lbl; headerRow.appendChild(th); });
            thead.appendChild(headerRow); tableEl.appendChild(thead);
            
            const tbody = document.createElement("tbody");
            tableEl.appendChild(tbody);
            log.appendChild(tableEl);
            
            currentTable = tableEl;
            currentTbody = tbody;
        }
        
        // Add new rows
        const existingRowCount = currentTbody.children.length;
        const newRecords = progress.records.slice(existingRowCount);
        
        newRecords.forEach((rec, idx) => {
            const tr = document.createElement("tr");
            
            // Add row number cell
            const rowNumTd = document.createElement("td");
            rowNumTd.textContent = existingRowCount + idx + 1;
            rowNumTd.style.textAlign = "right";
            rowNumTd.style.color = "#666";
            tr.appendChild(rowNumTd);
            
            headers.forEach(h => {
                const td = document.createElement("td");
                let val = rec[h];
                if (val === null || val === undefined) td.textContent = "";
                else if (typeof val === "object") {
                    if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                    else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
                } else td.textContent = String(val);
                tr.appendChild(td);
            });
            currentTbody.appendChild(tr);
        });
        
        // Update counter
        if (progress.done) {
            const totalSize = progress.totalSize || progress.fetchedCount;
            if (totalSize > progress.fetchedCount) {
                document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} of ${totalSize}`;
            } else {
                document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount}`;
            }
        } else {
            document.getElementById('resultsCount').textContent = `Results: ${progress.fetchedCount} of ${progress.totalSize} (fetching page ${progress.pageNumber}...)`;
        }
    });
}

// Ctrl+E handler supporting multi-line SOQL separated by blank lines
editor.addEventListener("keydown",async e=>{
    if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='e'){
        e.preventDefault(); if(!window.api){ alert("Error: API not loaded."); return; }

        const text = editor.value;
        const cursorPos = editor.selectionStart;

        // Find the block containing the cursor
        const lines = text.split('\n');
        let charPos = 0;
        let blockStart = -1;
        let blockEnd = -1;
        let blockLines = [];
        let inBlock = false;
        
        for(let i = 0; i < lines.length; i++){
            const line = lines[i];
            const lineStart = charPos;
            const lineEnd = charPos + line.length;
            
            if(line.trim() === ''){
                if(inBlock){
                    blockEnd = charPos - 1; // End before the empty line
                    if(cursorPos >= blockStart && cursorPos <= blockEnd) break;
                    blockStart = -1;
                    blockLines = [];
                    inBlock = false;
                }
            } else {
                if(!inBlock){
                    blockStart = lineStart;
                    inBlock = true;
                }
                blockLines.push(line);
                blockEnd = lineEnd;
            }
            charPos += line.length + 1; // +1 for newline
        }
        
        // Check if cursor is in the found block
        if(blockStart === -1 || cursorPos < blockStart || cursorPos > blockEnd){
            return;
        }
        
        const targetBlock = blockLines.map(l => l.trim()).join('\n').trim();
        if(!targetBlock) return;

        // Highlight the block being executed
        editor.setSelectionRange(blockStart, blockEnd);
        editor.focus();

        log.innerHTML='';
        currentTable = null;
        currentTbody = null;
        currentQueryId = 'query_' + Date.now();
        document.getElementById('resultsCount').textContent = '';
        document.getElementById('stopQueryBtn').style.display = 'inline-block';
        document.body.style.cursor = 'wait';
        editor.style.cursor = 'wait';
        try{
            const soqlKeywords=/^(SELECT|UPDATE|DELETE|INSERT|UPSERT|MERGE)\b/i;
            if(soqlKeywords.test(targetBlock)){
                // Remove // and -- comments from SOQL
                const cleanedBlock = targetBlock.split('\n').map(l=>l.replace(/(\/\/|--).*/,'').trim()).join('\n').trim();
                const result = await window.api.executeSOQL(cleanedBlock, currentQueryId);
                renderResult(result);
            } else {
                // Treat each non-empty line as a REST path
                const lines = targetBlock.split("\n").map(l=>l.trim()).filter(l=>l);
                for(const path of lines){
                    try{
                        // Remove // and -- comments from REST paths
                        const cleanedPath = path.replace(/(\/\/|--).*/,'').trim();
                        if(!cleanedPath) continue;
                        const res = await window.api.executeREST(cleanedPath);
                        renderResult(res);
                    } catch(err){
                        const errEl=document.createElement("div"); errEl.className="log-line";
                        errEl.innerHTML=`‚ùå ${err.message.replace(/\n/g,'<br>')}`;
                        log.appendChild(errEl);
                    }
                }
            }
        } catch(err){
            const errEl=document.createElement("div"); errEl.className="log-line";
            // Check if it was aborted
            if (err.name === 'AbortError' || err.message.includes('aborted')) {
                errEl.style.background = '#fff3cd';
                errEl.style.color = '#856404';
                errEl.innerHTML = '‚èπ Query was stopped';
            } else {
                errEl.innerHTML=`‚ùå ${err.message.replace(/\n/g,'<br>')}`;
            }
            log.appendChild(errEl);
        }
        document.getElementById('stopQueryBtn').style.display = 'none';
        currentQueryId = null;
        document.body.style.cursor = 'default';
        editor.style.cursor = 'text';
        log.scrollTop = 0;
    }
});

// Render results helper
function renderResult(result) {
    // If table was already rendered progressively, just update the final counter
    if (currentTable && currentTbody) {
        const records = result.records || result;
        const totalSize = result.totalSize || records.length;
        if (totalSize > records.length) {
            document.getElementById('resultsCount').textContent = `Results: ${records.length} of ${totalSize}`;
        } else {
            document.getElementById('resultsCount').textContent = `Results: ${records.length}`;
        }
        return;
    }
    
    if (result && result.totalSize !== undefined && (!result.records || result.records.length === 0)) {
        const tableEl = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        const th = document.createElement("th"); th.textContent = "COUNT";
        headerRow.appendChild(th); thead.appendChild(headerRow); tableEl.appendChild(thead);
        const tbody = document.createElement("tbody");
        const tr = document.createElement("tr"); const td = document.createElement("td");
        td.textContent = result.totalSize; tr.appendChild(td); tbody.appendChild(tr); tableEl.appendChild(tbody);
        log.appendChild(tableEl);
        document.getElementById('resultsCount').textContent = `Results: ${result.totalSize}`;
        return;
    }

    if (!result.records && !Array.isArray(result)) {
        const pre = document.createElement("pre");
        pre.textContent = JSON.stringify(result, null, 2);
        log.appendChild(pre);
        document.getElementById('resultsCount').textContent = 'Results: JSON Response';
        return;
    }

    const records = result.records || result;
    if (!records || records.length === 0) {
        const emptyEl = document.createElement("div");
        emptyEl.className = "log-line";
        emptyEl.textContent = "‚ö†Ô∏è No records returned.";
        log.appendChild(emptyEl);
        document.getElementById('resultsCount').textContent = 'Results: 0';
        return;
    }

    const headers = Object.keys(records[0]).filter(h => h !== "attributes");
    if (headers.length === 0) {
        const emptyEl = document.createElement("div");
        emptyEl.className = "log-line";
        emptyEl.textContent = "‚ö†Ô∏è No fields to display.";
        log.appendChild(emptyEl);
        return;
    }

    const headerLabels = headers.map(h => (/^expr\d+$/i.test(h) && headers.length === 1) ? "COUNT" : h);
    const tableEl = document.createElement("table");
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    
    // Add row number column header
    const rowNumTh = document.createElement("th");
    rowNumTh.textContent = "#";
    rowNumTh.style.width = "40px";
    rowNumTh.style.textAlign = "right";
    headerRow.appendChild(rowNumTh);
    
    headerLabels.forEach(lbl => { const th = document.createElement("th"); th.textContent = lbl; headerRow.appendChild(th); });
    thead.appendChild(headerRow); tableEl.appendChild(thead);

    const tbody = document.createElement("tbody");
    
    // Store references for progressive rendering
    currentTable = tableEl;
    currentTbody = tbody;
    records.forEach((rec, index) => {
        const tr = document.createElement("tr");
        
        // Add row number cell
        const rowNumTd = document.createElement("td");
        rowNumTd.textContent = index + 1;
        rowNumTd.style.textAlign = "right";
        rowNumTd.style.color = "#666";
        tr.appendChild(rowNumTd);
        
        headers.forEach(h => {
            const td = document.createElement("td");
            let val = rec[h];
            if (val === null || val === undefined) td.textContent = "";
            else if (typeof val === "object") {
                if (val.Id && (val.Name || val.name)) td.textContent = val.Name || val.name;
                else { try { td.textContent = JSON.stringify(val); } catch { td.textContent = String(val); } }
            } else td.textContent = String(val);
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });

    tableEl.appendChild(tbody);
    log.appendChild(tableEl);
    
    // Update results counter - show if pagination occurred
    const totalSize = result.totalSize || records.length;
    if (totalSize > records.length) {
        document.getElementById('resultsCount').textContent = `Results: ${records.length} of ${totalSize}`;
    } else {
        document.getElementById('resultsCount').textContent = `Results: ${records.length}`;
    }
}

document.addEventListener('DOMContentLoaded',()=>{ if(window.api) loadEnvironments(); });
</script>
</body>
</html>
